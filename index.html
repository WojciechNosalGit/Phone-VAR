<!DOCTYPE html>
<html lang="pl">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover"
    />
    <title>Kosmiczna Matematyka</title>
    <!-- PeerJS Library -->
    <script src="https://cdn.jsdelivr.net/npm/peerjs@1.5.4/dist/peerjs.min.js"></script>
    <!-- QR Code Library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      input,
      button,
      select,
      textarea {
        touch-action: manipulation;
      }

      body {
        font-family: "Comic Sans MS", cursive, sans-serif;
        background: #000;
        overflow: hidden;
        position: relative;
        width: 100vw;
        height: 100vh;
        -webkit-tap-highlight-color: transparent;
      }

      /* Animated cosmic background */
      .space-bg {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: radial-gradient(
            ellipse at 20% 30%,
            rgba(120, 81, 169, 0.3) 0%,
            transparent 50%
          ),
          radial-gradient(
            ellipse at 80% 70%,
            rgba(74, 144, 226, 0.3) 0%,
            transparent 50%
          ),
          radial-gradient(
            ellipse at 50% 50%,
            rgba(138, 43, 226, 0.2) 0%,
            transparent 70%
          ),
          linear-gradient(180deg, #0a0e27 0%, #1a0b2e 50%, #16213e 100%);
        z-index: 0;
        animation: cosmicPulse 15s ease-in-out infinite;
      }

      @keyframes cosmicPulse {
        0%,
        100% {
          opacity: 1;
        }
        50% {
          opacity: 0.8;
        }
      }

      .stars {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        z-index: 1;
      }

      .star {
        position: absolute;
        width: 2px;
        height: 2px;
        background: white;
        border-radius: 50%;
        animation: twinkle 3s infinite;
        box-shadow: 0 0 3px rgba(255, 255, 255, 0.5);
      }

      @keyframes twinkle {
        0%,
        100% {
          opacity: 0.3;
          transform: scale(1);
        }
        50% {
          opacity: 1;
          transform: scale(1.2);
        }
      }

      /* Profile Setup Screen */
      .profile-setup-screen {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 4000;
      }

      .profile-setup-container {
        background: rgba(20, 20, 40, 0.95);
        padding: 40px;
        border-radius: 20px;
        border: 3px solid rgba(102, 126, 234, 0.5);
        box-shadow: 0 10px 50px rgba(0, 0, 0, 0.5);
        max-width: 500px;
        width: 90%;
        color: white;
        text-align: center;
      }

      .profile-setup-container h1 {
        font-size: 32px;
        margin-bottom: 10px;
        text-shadow: 0 0 20px rgba(102, 126, 234, 0.8);
      }

      .profile-setup-container h2 {
        font-size: 20px;
        margin-bottom: 30px;
        color: #ffd43b;
      }

      .profile-setup-container input {
        width: 100%;
        padding: 15px;
        font-size: 18px;
        border: 3px solid #667eea;
        border-radius: 10px;
        margin-bottom: 20px;
        font-family: inherit;
        text-align: center;
      }

      .profile-color-selector,
      .edit-color-selector {
        display: grid;
        grid-template-columns: repeat(4, 1fr);
        gap: 15px;
        margin: 20px 0;
        max-width: 400px;
        margin-left: auto;
        margin-right: auto;
      }

      .profile-color-option,
      .edit-color-option {
        width: 100%;
        aspect-ratio: 1;
        border-radius: 50%;
        border: 4px solid rgba(255, 255, 255, 0.3);
        cursor: pointer;
        transition: all 0.2s;
        touch-action: manipulation;
      }

      .profile-color-option:hover,
      .edit-color-option:hover {
        transform: scale(1.1);
      }

      .profile-color-option.selected,
      .edit-color-option.selected {
        border: 5px solid white;
        transform: scale(1.15);
        box-shadow: 0 0 20px rgba(255, 255, 255, 0.8);
      }

      /* Profile Edit Button */
      .profile-display {
        position: absolute;
        top: 20px;
        left: 20px;
        z-index: 9999;
        display: flex;
        flex-direction: column;
        gap: 8px;
        pointer-events: auto !important;
      }

      .profile-info {
        display: flex;
        align-items: center;
        gap: 12px;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        padding: 10px 16px;
        border-radius: 10px;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        border: 2px solid rgba(255, 255, 255, 0.5);
        pointer-events: none;
      }

      .profile-name {
        color: white;
        font-size: 18px;
        font-weight: bold;
        font-family: inherit;
      }

      .profile-color-dot {
        width: 24px;
        height: 24px;
        border-radius: 50%;
        border: 3px solid white;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.4);
      }

      .profile-edit-icon {
        align-self: flex-start;
        background: rgba(255, 255, 255, 0.9);
        border: 2px solid rgba(102, 126, 234, 0.5);
        color: #667eea;
        padding: 8px 12px;
        border-radius: 8px;
        font-size: 18px;
        cursor: pointer;
        transition: all 0.2s;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        pointer-events: auto !important;
        z-index: 10000;
        position: relative;
      }

      .profile-edit-icon:hover {
        transform: scale(1.1);
        background: white;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
      }

      /* Profile Edit Modal */
      .profile-edit-modal {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 5000;
        background: rgba(0, 0, 0, 0.7);
      }

      .profile-edit-container {
        background: rgba(20, 20, 40, 0.98);
        padding: 40px;
        border-radius: 20px;
        border: 3px solid rgba(102, 126, 234, 0.5);
        box-shadow: 0 10px 50px rgba(0, 0, 0, 0.5);
        max-width: 500px;
        width: 90%;
        color: white;
        text-align: center;
      }

      .profile-edit-container h2 {
        font-size: 28px;
        margin-bottom: 30px;
        text-shadow: 0 0 20px rgba(102, 126, 234, 0.8);
      }

      .profile-edit-container input {
        width: 100%;
        padding: 15px;
        font-size: 18px;
        border: 3px solid #667eea;
        border-radius: 10px;
        margin-bottom: 20px;
        font-family: inherit;
        text-align: center;
      }

      /* Setup screen */
      .setup-screen {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(10, 14, 39, 0.95);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 1000;
      }

      .setup-container {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        padding: 40px;
        border-radius: 20px;
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5),
          0 0 100px rgba(102, 126, 234, 0.3);
        max-width: 600px;
        width: 90%;
        border: 2px solid rgba(255, 255, 255, 0.2);
        position: relative;
      }

      .setup-title {
        text-align: center;
        font-size: 36px;
        color: white;
        margin-bottom: 30px;
        text-shadow: 3px 3px 6px rgba(0, 0, 0, 0.3),
          0 0 20px rgba(255, 255, 255, 0.5);
      }

      .player-setup {
        background: rgba(255, 255, 255, 0.95);
        padding: 20px;
        border-radius: 15px;
        margin-bottom: 15px;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      }

      .player-setup h3 {
        color: #667eea;
        margin-bottom: 15px;
      }

      .player-setup input {
        width: 100%;
        padding: 12px;
        font-size: 16px;
        border: 2px solid #667eea;
        border-radius: 8px;
        margin-bottom: 10px;
        font-family: inherit;
      }

      .player-setup input.error {
        border-color: #ff6b6b;
      }

      .error-message {
        color: #ff6b6b;
        font-size: 14px;
        margin-top: -5px;
        margin-bottom: 10px;
        display: none;
      }

      .error-message.show {
        display: block;
      }

      .color-selector {
        display: grid;
        grid-template-columns: repeat(5, 1fr);
        gap: 8px;
        justify-items: center;
        margin-bottom: 10px;
      }

      .color-option {
        width: 45px;
        height: 45px;
        border-radius: 50%;
        border: 3px solid #ccc;
        cursor: pointer;
        transition: all 0.3s;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
      }

      .color-option:hover {
        transform: scale(1.15);
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
      }

      .color-option.selected {
        border: 5px solid #333;
        transform: scale(1.2);
        box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
      }

      .color-option.disabled {
        opacity: 0.3;
        cursor: not-allowed;
      }

      .add-player-btn,
      .start-game-btn {
        width: 100%;
        padding: 15px;
        font-size: 18px;
        font-weight: bold;
        border: none;
        border-radius: 10px;
        cursor: pointer;
        margin-top: 10px;
        transition: all 0.3s;
        font-family: inherit;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
      }

      .add-player-btn {
        background: linear-gradient(135deg, #51cf66 0%, #40c057 100%);
        color: white;
      }

      .add-player-btn:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.3);
      }

      .add-player-btn:disabled {
        background: #ccc;
        cursor: not-allowed;
        transform: none;
      }

      .start-game-btn {
        background: linear-gradient(135deg, #ff6b6b 0%, #fa5252 100%);
        color: white;
      }

      .start-game-btn:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.3);
      }

      .start-game-btn:disabled {
        background: #ccc;
        cursor: not-allowed;
        transform: none;
      }

      /* Online Mode Button */
      .online-mode-btn {
        position: absolute;
        top: 20px;
        right: 20px;
        background: linear-gradient(135deg, #4dabf7 0%, #339af0 100%);
        color: white;
        border: none;
        padding: 15px 25px;
        border-radius: 12px;
        font-size: 18px;
        font-weight: bold;
        cursor: pointer;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        border: 2px solid rgba(255, 255, 255, 0.5);
        z-index: 100;
        transition: all 0.3s;
        font-family: inherit;
      }

      .online-mode-btn:hover {
        transform: scale(1.05);
        box-shadow: 0 6px 20px rgba(0, 0, 0, 0.4);
      }

      /* Online Lobby */
      .online-lobby {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(10, 14, 39, 0.95);
        z-index: 2000;
        align-items: center;
        justify-content: center;
      }

      .online-lobby-content {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        padding: 40px;
        border-radius: 20px;
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
        max-width: 600px;
        width: 90%;
        border: 2px solid rgba(255, 255, 255, 0.2);
        text-align: center;
      }

      .online-lobby-content h2 {
        color: white;
        font-size: 32px;
        margin-bottom: 20px;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
      }

      .qr-container {
        background: white;
        padding: 20px;
        border-radius: 15px;
        margin: 20px auto;
        display: inline-block;
      }

      .players-waiting {
        background: rgba(255, 255, 255, 0.9);
        padding: 20px;
        border-radius: 15px;
        margin: 20px 0;
      }

      .players-waiting h3 {
        color: #667eea;
        margin-bottom: 15px;
      }

      .player-item {
        padding: 10px;
        margin: 5px 0;
        background: rgba(102, 126, 234, 0.1);
        border-radius: 8px;
        display: flex;
        align-items: center;
        gap: 10px;
      }

      .player-color-dot {
        width: 20px;
        height: 20px;
        border-radius: 50%;
        border: 2px solid white;
      }

      .start-online-btn {
        width: 100%;
        padding: 15px;
        font-size: 20px;
        font-weight: bold;
        background: linear-gradient(135deg, #51cf66 0%, #40c057 100%);
        color: white;
        border: none;
        border-radius: 10px;
        cursor: pointer;
        margin-top: 20px;
        font-family: inherit;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
      }

      .start-online-btn:disabled {
        background: #ccc;
        cursor: not-allowed;
      }

      .close-online-btn {
        background: rgba(255, 255, 255, 0.2);
        color: white;
        border: 2px solid white;
        padding: 10px 20px;
        border-radius: 8px;
        cursor: pointer;
        margin-top: 10px;
        font-family: inherit;
        font-size: 16px;
      }

      /* Game Screen */
      .game-screen {
        display: none;
        position: relative;
        width: 100%;
        height: 100%;
        z-index: 10;
      }

      .game-container {
        width: 100%;
        height: 100%;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        padding: 20px;
      }

      .title {
        font-size: 32px;
        color: white;
        text-shadow: 0 0 20px rgba(102, 126, 234, 0.8),
          3px 3px 6px rgba(0, 0, 0, 0.5);
        margin-bottom: 20px;
        text-align: center;
      }

      .board-wrapper {
        position: relative;
        background: rgba(255, 255, 255, 0.05);
        border-radius: 20px;
        padding: 30px;
        box-shadow: 0 10px 50px rgba(0, 0, 0, 0.5),
          0 0 100px rgba(102, 126, 234, 0.2);
        border: 2px solid rgba(255, 255, 255, 0.1);
        margin-bottom: 20px;
      }

      .board {
        position: relative;
        width: 800px;
        height: 600px;
        background: rgba(10, 14, 39, 0.8);
        border-radius: 15px;
        border: 3px solid rgba(102, 126, 234, 0.5);
        box-shadow: inset 0 0 50px rgba(102, 126, 234, 0.1);
      }

      /* Card Decks - OUTSIDE the board */
      .card-decks {
        position: fixed;
        bottom: 50px;
        left: 50px;
        display: flex;
        gap: 20px;
        z-index: 150;
      }

      .card-deck {
        position: relative;
        width: 70px;
        height: 100px;
      }

      .deck-card {
        position: absolute;
        width: 70px;
        height: 100px;
        background: white;
        border-radius: 10px;
        border: 4px solid rgba(0, 0, 0, 0.4);
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 45px;
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.4);
        transition: all 0.3s;
      }

      .deck-card.white {
        background: linear-gradient(135deg, #e9ecef 0%, #dee2e6 100%);
        color: #333;
      }

      .deck-card.green {
        background: linear-gradient(135deg, #51cf66 0%, #40c057 100%);
        color: white;
      }

      .deck-card.yellow {
        background: linear-gradient(135deg, #ffd43b 0%, #fcc419 100%);
        color: #333;
      }

      .deck-card.red {
        background: linear-gradient(135deg, #ff6b6b 0%, #fa5252 100%);
        color: white;
      }

      /* Card animation */
      @keyframes cardDrawAwesome {
        0% {
          transform: translate(0, 0) scale(1) rotate(0deg);
          opacity: 1;
        }
        40% {
          transform: translate(600px, -350px) scale(1.8) rotate(360deg);
          opacity: 1;
        }
        60% {
          transform: translate(600px, -350px) scale(1.8) rotate(360deg);
          opacity: 1;
        }
        100% {
          transform: translate(600px, -350px) scale(0) rotate(720deg);
          opacity: 0;
        }
      }

      .card-drawing {
        animation: cardDrawAwesome 1.2s ease-in-out forwards;
        z-index: 3000;
      }

      /* Space styling */
      .space {
        position: absolute;
        width: 40px;
        height: 40px;
        border-radius: 50%;
        border: 3px solid rgba(255, 255, 255, 0.3);
        display: flex;
        align-items: center;
        justify-content: center;
        font-weight: bold;
        box-shadow: 0 0 15px rgba(255, 255, 255, 0.3);
        transition: all 0.3s;
      }

      .space.white {
        background: linear-gradient(135deg, #e9ecef 0%, #dee2e6 100%);
        color: #333;
      }

      .space.green {
        background: linear-gradient(135deg, #51cf66 0%, #40c057 100%);
        color: white;
        box-shadow: 0 0 20px rgba(81, 207, 102, 0.6);
      }

      .space.yellow {
        background: linear-gradient(135deg, #ffd43b 0%, #fcc419 100%);
        color: #333;
        box-shadow: 0 0 20px rgba(255, 212, 59, 0.6);
      }

      .space.red {
        background: linear-gradient(135deg, #ff6b6b 0%, #fa5252 100%);
        color: white;
        box-shadow: 0 0 20px rgba(255, 107, 107, 0.6);
      }

      .space.purple {
        background: linear-gradient(135deg, #9b59b6 0%, #8e44ad 100%);
        color: white;
        box-shadow: 0 0 20px rgba(155, 89, 182, 0.8);
        font-size: 28px;
        font-weight: 900;
      }

      /* Path connections */
      .path-line {
        stroke: rgba(255, 255, 255, 0.3);
        stroke-width: 3;
        fill: none;
        filter: drop-shadow(0 0 5px rgba(255, 255, 255, 0.5));
      }

      .teleport-line {
        stroke: white;
        stroke-width: 5;
        fill: none;
        stroke-dasharray: 10, 5;
        filter: drop-shadow(0 0 10px rgba(255, 255, 255, 1));
        opacity: 0;
        animation: teleportFlash 0.8s ease-in-out infinite;
      }

      @keyframes teleportFlash {
        0%,
        100% {
          opacity: 0;
        }
        50% {
          opacity: 1;
        }
      }

      /* Player pieces */
      .player-piece {
        position: absolute;
        width: 30px;
        height: 30px;
        border-radius: 50%;
        border: 3px solid white;
        transition: left 0.15s cubic-bezier(0.68, -0.55, 0.265, 1.55),
          top 0.15s cubic-bezier(0.68, -0.55, 0.265, 1.55), transform 0.1s ease;
        z-index: 100;
        box-shadow: 0 0 15px rgba(0, 0, 0, 0.5), 0 0 30px currentColor;
        animation: playerGlow 2s ease-in-out infinite;
      }

      @keyframes playerGlow {
        0%,
        100% {
          box-shadow: 0 0 15px rgba(0, 0, 0, 0.5), 0 0 20px currentColor;
        }
        50% {
          box-shadow: 0 0 20px rgba(0, 0, 0, 0.7), 0 0 35px currentColor;
        }
      }

      @keyframes bounce {
        0%,
        100% {
          transform: translateY(0) scale(1);
        }
        50% {
          transform: translateY(-20px) scale(1.1);
        }
      }

      /* Markers */
      .start-marker {
        position: absolute;
        left: 25px;
        top: 25px;
        background: linear-gradient(135deg, #51cf66 0%, #40c057 100%);
        color: white;
        padding: 8px 15px;
        border-radius: 10px;
        font-weight: bold;
        font-size: 14px;
        box-shadow: 0 0 20px rgba(81, 207, 102, 0.8);
        border: 2px solid rgba(255, 255, 255, 0.5);
        z-index: 200;
      }

      .finish-marker {
        position: absolute;
        left: 25px;
        bottom: 25px;
        background: linear-gradient(135deg, #ff6b6b 0%, #fa5252 100%);
        color: white;
        padding: 8px 15px;
        border-radius: 10px;
        font-weight: bold;
        font-size: 14px;
        box-shadow: 0 0 30px rgba(255, 107, 107, 1);
        border: 2px solid rgba(255, 255, 255, 0.5);
        z-index: 200;
        animation: finishPulse 2s ease-in-out infinite;
      }

      @keyframes finishPulse {
        0%,
        100% {
          transform: scale(1);
        }
        50% {
          transform: scale(1.1);
        }
      }

      /* Controls */
      .controls {
        text-align: center;
        background: rgba(255, 255, 255, 0.1);
        padding: 20px;
        border-radius: 15px;
        border: 2px solid rgba(255, 255, 255, 0.2);
      }

      .current-player {
        font-size: 24px;
        color: white;
        margin-bottom: 15px;
        text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
      }

      .btn {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        border: none;
        padding: 15px 30px;
        font-size: 20px;
        font-weight: bold;
        border-radius: 10px;
        cursor: pointer;
        transition: all 0.3s;
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        font-family: inherit;
      }

      .btn:hover:not(:disabled) {
        transform: translateY(-2px);
        box-shadow: 0 7px 20px rgba(0, 0, 0, 0.4);
      }

      .btn:active:not(:disabled) {
        transform: translateY(0);
      }

      .btn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }

      .dice-result {
        margin-top: 15px;
        font-size: 20px;
        color: white;
        min-height: 30px;
      }

      /* Question Modal */
      .question-modal {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.8);
        align-items: center;
        justify-content: center;
        z-index: 2000;
      }

      .question-content {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        padding: 40px;
        border-radius: 20px;
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
        text-align: center;
        max-width: 500px;
        width: 90%;
        border: 3px solid rgba(255, 255, 255, 0.3);
        position: relative;
      }

      .question-timer {
        position: absolute;
        top: 15px;
        right: 15px;
        background: rgba(255, 255, 255, 0.9);
        color: #667eea;
        padding: 8px 15px;
        border-radius: 8px;
        font-weight: bold;
        font-size: 18px;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
      }

      .question-timer.warning {
        background: #ffd43b;
        color: #333;
        animation: timerPulse 0.5s ease-in-out infinite;
      }

      .question-timer.danger {
        background: #ff6b6b;
        color: white;
        animation: timerPulse 0.3s ease-in-out infinite;
      }

      @keyframes timerPulse {
        0%,
        100% {
          transform: scale(1);
        }
        50% {
          transform: scale(1.1);
        }
      }

      .question-content h2 {
        color: white;
        font-size: 28px;
        margin-bottom: 25px;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        transition: opacity 0.2s ease;
      }

      .question-content input {
        width: 100%;
        padding: 15px;
        font-size: 20px;
        border: none;
        border-radius: 10px;
        margin-bottom: 20px;
        text-align: center;
        font-family: inherit;
      }

      .question-content button {
        width: 100%;
        padding: 15px;
        font-size: 20px;
        font-weight: bold;
        background: linear-gradient(135deg, #51cf66 0%, #40c057 100%);
        color: white;
        border: none;
        border-radius: 10px;
        cursor: pointer;
        transition: all 0.3s;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
        font-family: inherit;
      }

      .question-content button:hover:not(:disabled) {
        transform: translateY(-2px);
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.3);
      }

      .question-content button:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }

      .correct-answer {
        margin-top: 15px;
        padding: 15px;
        background: rgba(255, 255, 255, 0.9);
        border-radius: 10px;
        font-size: 18px;
        font-weight: bold;
        color: #667eea;
        display: none;
      }

      /* Dice Animation */
      .dice-animation {
        display: none;
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 150px;
        height: 150px;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        border-radius: 20px;
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
        z-index: 3000;
        animation: diceRoll 0.5s ease-in-out;
        border: 5px solid rgba(255, 255, 255, 0.5);
      }

      @keyframes diceRoll {
        0%,
        100% {
          transform: translate(-50%, -50%) rotate(0deg);
        }
        25% {
          transform: translate(-50%, -50%) rotate(90deg);
        }
        50% {
          transform: translate(-50%, -50%) rotate(180deg);
        }
        75% {
          transform: translate(-50%, -50%) rotate(270deg);
        }
      }

      .dice-number {
        width: 100%;
        height: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 80px;
        color: white;
        font-weight: bold;
        text-shadow: 3px 3px 6px rgba(0, 0, 0, 0.3);
      }

      /* Temporary Notification */
      .temp-notification {
        display: none;
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: white;
        color: #333;
        padding: 30px 50px;
        border-radius: 15px;
        font-size: 24px;
        font-weight: bold;
        box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
        z-index: 3500;
        text-align: center;
        white-space: pre-line;
      }

      .temp-notification.success {
        background: linear-gradient(135deg, #51cf66 0%, #40c057 100%);
        color: white;
      }

      .temp-notification.error {
        background: linear-gradient(135deg, #ff6b6b 0%, #fa5252 100%);
        color: white;
      }

      /* Instructions Button and Panel */
      .instructions-toggle {
        position: absolute;
        top: 20px;
        right: 20px;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        border: none;
        padding: 12px 20px;
        border-radius: 10px;
        font-size: 20px;
        font-weight: bold;
        cursor: pointer;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        border: 2px solid rgba(255, 255, 255, 0.5);
        z-index: 150;
        transition: all 0.3s;
        font-family: inherit;
      }

      .instructions-toggle:hover {
        transform: scale(1.05);
        box-shadow: 0 6px 20px rgba(0, 0, 0, 0.4);
      }

      .instructions-panel {
        position: absolute;
        top: 70px;
        right: 20px;
        background: rgba(255, 255, 255, 0.95);
        padding: 0;
        border-radius: 12px;
        font-size: 13px;
        line-height: 1.6;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        border: 2px solid rgba(102, 126, 234, 0.5);
        max-width: 280px;
        z-index: 149;
        max-height: 0;
        overflow-y: auto;
        overflow-x: hidden;
        opacity: 0;
        transition: max-height 0.5s ease, opacity 0.4s ease, padding 0.5s ease;
      }

      .instructions-panel.open {
        max-height: 500px;
        opacity: 1;
        padding: 20px;
      }

      .instructions-panel h3 {
        color: #667eea;
        margin-bottom: 10px;
        font-size: 16px;
        border-bottom: 2px solid #667eea;
        padding-bottom: 5px;
      }

      .instructions-panel p {
        margin-bottom: 10px;
      }

      .instructions-panel .rule-item {
        margin-bottom: 8px;
        padding-left: 5px;
      }

      .instructions-panel strong {
        color: #667eea;
      }

      /* Mobile Player Interface */
      /* CRITICAL: Disable ALL animations and transitions on mobile */
      .mobile-player-screen *,
      .mobile-player-screen *::before,
      .mobile-player-screen *::after {
        animation: none !important;
        transition: none !important;
      }

      .mobile-player-screen {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100vh;
        background: #1a1a2e;
        color: white;
        text-align: center;
        overflow: hidden;
        z-index: 3000;
        pointer-events: none;
        user-select: none;
        -webkit-user-select: none;
      }

      .mobile-player-screen.active {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        pointer-events: auto;
      }

      .mobile-player-screen h1 {
        font-size: 24px;
        margin-bottom: 20px;
        text-shadow: 0 0 20px rgba(102, 126, 234, 0.8);
      }

      .mobile-player-screen h2 {
        font-size: 20px;
        margin-bottom: 20px;
      }

      .mobile-player-screen input {
        width: 100%;
        max-width: 400px;
        padding: 15px;
        font-size: 16px;
        border: 3px solid #667eea;
        border-radius: 10px;
        margin-bottom: 20px;
        font-family: inherit;
        text-align: center;
        -webkit-user-select: text;
        user-select: text;
        touch-action: manipulation;
        -webkit-appearance: none;
        appearance: none;
        background: white;
      }

      #mobileQuestionScreen input {
        font-size: 32px;
        padding: 20px;
        border-radius: 15px;
        font-weight: bold;
      }

      #mobileQuestionScreen .mobile-btn {
        font-size: 28px;
        padding: 22px;
        border-radius: 15px;
      }

      .mobile-player-screen input:focus {
        outline: none;
        border-color: #51cf66;
        touch-action: manipulation;
        background: white;
      }

      .mobile-btn {
        width: 100%;
        max-width: 400px;
        padding: 18px;
        font-size: 20px;
        font-weight: bold;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        border: none;
        border-radius: 12px;
        cursor: pointer;
        font-family: inherit;
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        transition: transform 0.1s ease-out, opacity 0.1s ease-out;
        margin: 10px 0;
        touch-action: manipulation;
        -webkit-tap-highlight-color: transparent;
        user-select: none;
        -webkit-user-select: none;
      }

      .mobile-btn:active:not(:disabled) {
        transform: scale(0.97);
      }

      .mobile-btn:disabled {
        opacity: 0.3;
        cursor: not-allowed;
        background: #555;
      }

      .mobile-btn.roll {
        background: linear-gradient(135deg, #51cf66 0%, #40c057 100%);
        font-size: 42px;
        padding: 50px 60px;
        border-radius: 20px;
        box-shadow: 0 8px 30px rgba(81, 207, 102, 0.4);
        width: 80%;
        max-width: 300px;
      }

      .mobile-btn.roll:disabled {
        background: #333;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
      }

      #mobileGameScreen {
        gap: 20px;
        padding: 20px;
      }

      .status-message {
        background: rgba(102, 126, 234, 0.2);
        padding: 25px;
        border-radius: 15px;
        margin: 20px 0;
        font-size: 20px;
        max-width: 400px;
        width: 90%;
        border: 2px solid rgba(102, 126, 234, 0.3);
      }

      .players-list {
        background: rgba(255, 255, 255, 0.1);
        padding: 20px;
        border-radius: 12px;
        margin: 20px 0;
        max-width: 400px;
        width: 100%;
      }

      .current-turn {
        background: rgba(81, 207, 102, 0.3);
        border: 2px solid #51cf66;
      }

      #mobileQuestionScreen {
        background: #1a1a2e;
        padding: 40px 20px;
      }

      .question-box {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        padding: 50px 30px;
        border-radius: 25px;
        width: 90%;
        max-width: 500px;
        box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
        border: 3px solid rgba(255, 255, 255, 0.3);
      }

      .question-box input {
        -webkit-user-select: text;
        user-select: text;
        -webkit-appearance: none;
        appearance: none;
      }

      .question-box input:focus {
        outline: none;
        border: 3px solid #51cf66;
      }

      .question-text {
        font-size: 36px;
        margin: 30px 0;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        word-wrap: break-word;
        overflow-wrap: break-word;
        font-weight: bold;
      }

      .timer {
        font-size: 32px;
        font-weight: bold;
        margin: 10px 0;
        padding: 15px;
        background: rgba(255, 255, 255, 0.2);
        border-radius: 12px;
      }

      .timer.warning {
        background: #ffd43b;
        color: #333;
      }

      .timer.danger {
        background: #ff6b6b;
        animation: pulse 0.5s infinite;
      }

      @keyframes pulse {
        0%,
        100% {
          transform: scale(1);
        }
        50% {
          transform: scale(1.1);
        }
      }

      .success-message {
        background: #51cf66;
        color: white;
        padding: 15px;
        border-radius: 10px;
        margin: 20px 0;
        font-size: 20px;
        max-width: 400px;
        width: 100%;
      }

      .error-msg {
        background: #ff6b6b;
        color: white;
        padding: 15px;
        border-radius: 10px;
        margin: 20px 0;
        max-width: 400px;
        width: 100%;
      }

      .loading {
        font-size: 18px;
        opacity: 0.7;
        /* DISABLED animation - mo≈ºe powodowaƒá problemy */
        /* animation: blink 1.5s infinite; */
      }

      @keyframes blink {
        0%,
        100% {
          opacity: 0.7;
        }
        50% {
          opacity: 0.3;
        }
      }
    </style>
  </head>
  <body>
    <!-- Space background -->
    <div class="space-bg"></div>
    <div class="stars" id="stars"></div>

    <!-- Profile Setup Screen (First Time) -->
    <div
      class="profile-setup-screen"
      id="profileSetupScreen"
      style="display: none"
    >
      <div class="profile-setup-container">
        <h1>üöÄ Kosmiczna Matematyka</h1>
        <h2>Witaj! Utw√≥rz sw√≥j profil gracza</h2>

        <input
          type="text"
          id="profileNameInput"
          placeholder="Wpisz swojƒÖ nazwƒô"
          maxlength="15"
          autocomplete="off"
          autocorrect="off"
          autocapitalize="words"
        />

        <p style="font-size: 18px; margin: 20px 0 10px 0">
          Wybierz sw√≥j domy≈õlny kolor:
        </p>

        <div class="profile-color-selector">
          <div
            class="profile-color-option"
            data-color="blue"
            style="background: #4dabf7"
          ></div>
          <div
            class="profile-color-option"
            data-color="red"
            style="background: #ff6b6b"
          ></div>
          <div
            class="profile-color-option"
            data-color="green"
            style="background: #51cf66"
          ></div>
          <div
            class="profile-color-option"
            data-color="yellow"
            style="background: #ffd43b"
          ></div>
          <div
            class="profile-color-option"
            data-color="purple"
            style="background: #9b59b6"
          ></div>
          <div
            class="profile-color-option"
            data-color="orange"
            style="background: #ff922b"
          ></div>
          <div
            class="profile-color-option"
            data-color="pink"
            style="background: #ff6ba9"
          ></div>
          <div
            class="profile-color-option"
            data-color="cyan"
            style="background: #22b8cf"
          ></div>
        </div>

        <button type="button" class="btn" id="createProfileBtn" disabled>
          Zapisz profil
        </button>
      </div>
    </div>

    <!-- Profile Display (Top Left in Lobby) -->
    <div class="profile-display" id="profileDisplay" style="display: none">
      <div class="profile-info">
        <div class="profile-name">
          <span id="profileNameDisplay"></span>
        </div>
        <div class="profile-color-dot" id="profileColorDot"></div>
      </div>
      <button
        type="button"
        class="profile-edit-icon"
        id="profileEditBtn"
        title="Edytuj profil"
        onclick="openProfileEditModal()"
      >
        ‚úèÔ∏è
      </button>
    </div>

    <!-- Profile Edit Modal -->
    <div class="profile-edit-modal" id="profileEditModal" style="display: none">
      <div class="profile-edit-container">
        <h2>Edytuj profil</h2>

        <input
          type="text"
          id="editProfileNameInput"
          placeholder="Wpisz swojƒÖ nazwƒô"
          maxlength="15"
          autocomplete="off"
        />

        <p style="font-size: 16px; margin: 20px 0 10px 0">Domy≈õlny kolor:</p>

        <div class="edit-color-selector">
          <div
            class="edit-color-option"
            data-color="blue"
            style="background: #4dabf7"
          ></div>
          <div
            class="edit-color-option"
            data-color="red"
            style="background: #ff6b6b"
          ></div>
          <div
            class="edit-color-option"
            data-color="green"
            style="background: #51cf66"
          ></div>
          <div
            class="edit-color-option"
            data-color="yellow"
            style="background: #ffd43b"
          ></div>
          <div
            class="edit-color-option"
            data-color="purple"
            style="background: #9b59b6"
          ></div>
          <div
            class="edit-color-option"
            data-color="orange"
            style="background: #ff922b"
          ></div>
          <div
            class="edit-color-option"
            data-color="pink"
            style="background: #ff6ba9"
          ></div>
          <div
            class="edit-color-option"
            data-color="cyan"
            style="background: #22b8cf"
          ></div>
        </div>

        <div style="display: flex; gap: 10px; margin-top: 30px">
          <button type="button" class="btn" id="saveProfileBtn">Zapisz</button>
          <button
            type="button"
            class="btn"
            id="cancelEditBtn"
            style="background: #868e96"
          >
            Anuluj
          </button>
        </div>
      </div>
    </div>

    <!-- Setup Screen (Local Mode) -->
    <div class="setup-screen" id="setupScreen" style="display: none">
      <button class="online-mode-btn" onclick="openOnlineMode()">
        üåê TRYB ONLINE
      </button>
      <div class="setup-container">
        <div class="setup-title">üöÄ Kosmiczna Matematyka üåü</div>
        <div id="playersContainer"></div>
        <button class="add-player-btn" id="addPlayerBtn" onclick="addPlayer()">
          ‚ûï Dodaj Gracza
        </button>
        <button
          class="start-game-btn"
          id="startGameBtn"
          onclick="startGame()"
          disabled
        >
          üéÆ START GRY
        </button>
      </div>
    </div>

    <!-- Online Lobby -->
    <div class="online-lobby" id="onlineLobby">
      <div class="online-lobby-content">
        <h2>üåê Tryb Online</h2>
        <p style="color: white; margin-bottom: 20px" id="onlineStatusText">
          ≈ÅƒÖczenie...
        </p>

        <div class="qr-container" id="qrContainer">
          <div id="qrcode">
            <p style="color: #333">≈Åadowanie kodu QR...</p>
          </div>
        </div>

        <div class="players-waiting">
          <h3>Gracze w poczekalni:</h3>
          <div id="playersWaitingList">
            <p style="color: #999">Czekam na graczy...</p>
          </div>
        </div>

        <button
          class="start-online-btn"
          id="startOnlineBtn"
          onclick="startOnlineGame()"
          disabled
        >
          üéÆ START GRY (min. 2 graczy)
        </button>

        <button class="close-online-btn" onclick="closeOnlineMode()">
          ‚úï Zamknij
        </button>
      </div>
    </div>

    <!-- Rematch Voting Screen -->
    <div
      id="rematchVotingScreen"
      style="
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.9);
        z-index: 10000;
        display: none;
        align-items: center;
        justify-content: center;
      "
    >
      <div
        style="
          background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
          padding: 40px;
          border-radius: 20px;
          text-align: center;
          max-width: 500px;
          width: 90%;
          border: 3px solid rgba(255, 255, 255, 0.3);
        "
      >
        <h2 style="color: white; font-size: 32px; margin-bottom: 20px">
          üéÆ Zagraj ponownie?
        </h2>
        <div
          id="rematchTimer"
          style="
            color: white;
            font-size: 48px;
            font-weight: bold;
            margin: 20px 0;
          "
        >
          15
        </div>
        <div
          id="rematchVoteCount"
          style="color: white; font-size: 24px; margin: 20px 0"
        >
          0/4 graczy gotowych
        </div>
        <button
          id="rematchYesBtn"
          onclick="voteRematch(true)"
          style="
            background: #51cf66;
            color: white;
            border: none;
            padding: 20px 40px;
            font-size: 24px;
            border-radius: 12px;
            cursor: pointer;
            margin: 10px;
            font-weight: bold;
            box-shadow: 0 4px 15px rgba(81, 207, 102, 0.4);
          "
        >
          ‚úì TAK
        </button>
        <button
          id="rematchNoBtn"
          onclick="voteRematch(false)"
          style="
            background: #ff6b6b;
            color: white;
            border: none;
            padding: 20px 40px;
            font-size: 24px;
            border-radius: 12px;
            cursor: pointer;
            margin: 10px;
            font-weight: bold;
            box-shadow: 0 4px 15px rgba(255, 107, 107, 0.4);
          "
        >
          ‚úó NIE
        </button>
      </div>
    </div>

    <!-- Game Screen (Local + Online Host) -->
    <div class="game-screen" id="gameScreen">
      <!-- Card Decks -->
      <div class="card-decks">
        <div class="card-deck" id="whiteDeck">
          <div class="deck-card white">‚ùì</div>
        </div>
        <div class="card-deck" id="greenDeck">
          <div class="deck-card green">‚ùì</div>
        </div>
        <div class="card-deck" id="yellowDeck">
          <div class="deck-card yellow">‚ùì</div>
        </div>
        <div class="card-deck" id="redDeck">
          <div class="deck-card red">‚ùì</div>
        </div>
      </div>

      <div class="game-container">
        <div class="title">üöÄ Kosmiczna Matematyka üåü</div>

        <div class="board-wrapper">
          <div class="board" id="board">
            <div class="start-marker">START üöÄ</div>
            <div class="finish-marker">META üèÅ</div>

            <button class="instructions-toggle" onclick="toggleInstructions()">
              üìñ ZASADY
            </button>

            <div class="instructions-panel" id="instructionsPanel">
              <h3>üìñ Zasady Gry</h3>
              <p>
                <strong>üéØ Cel gry:</strong><br />
                Jako pierwszy dotrzeƒá do METY üèÅ!
              </p>
              <p>
                <strong>üé≤ Rozgrywka:</strong><br />
                ‚Ä¢ Gracze rzucajƒÖ kostkƒÖ po kolei<br />
                ‚Ä¢ Poruszasz siƒô o wyrzuconƒÖ liczbƒô p√≥l<br />
                ‚Ä¢ ≈öcie≈ºka biegnie wƒô≈ºykiem
              </p>
              <p>
                <strong>‚è±Ô∏è CZAS NA ODPOWIED≈π:</strong><br />
                ‚Ä¢ Bia≈Çe: 30 sek<br />
                ‚Ä¢ ≈Åatwe: 30 sek<br />
                ‚Ä¢ ≈örednie: 60 sek<br />
                ‚Ä¢ Trudne: 90 sek<br />
                ‚Ä¢ Fioletowe: 90 sek
              </p>
              <p>
                <strong>‚ö™ BIA≈ÅE:</strong><br />
                Dobra: Zostajesz w miejscu<br />
                Z≈Ça: -4 pola
              </p>
              <p>
                <strong>üü¢ ≈ÅATWE:</strong><br />
                Dobra: +1 pole<br />
                Z≈Ça: -3 pola
              </p>
              <p>
                <strong>üü° ≈öREDNIE:</strong><br />
                Dobra: +2 pola + BONUS RZUT<br />
                Z≈Ça: -2 pola
              </p>
              <p>
                <strong>üî¥ TRUDNE:</strong><br />
                Dobra: +3 pola + BONUS RZUT<br />
                Z≈Ça: -1 pole
              </p>
              <p>
                <strong>üü£ TELEPORT:</strong><br />
                Dobra: TELEPORTACJA<br />
                Z≈Ça: Zostajesz na miejscu
              </p>
            </div>
          </div>
        </div>

        <div class="controls" id="localControls">
          <div class="current-player" id="currentPlayer"></div>
          <button class="btn" id="rollDiceBtn" onclick="rollDice()">
            üé≤ RZUƒÜ KOSTKƒÑ
          </button>
          <div class="dice-result" id="diceResult"></div>
        </div>
      </div>
    </div>

    <!-- Mobile Player Screens -->
    <!-- Join Screen -->
    <!-- Waiting Screen -->
    <div class="mobile-player-screen" id="mobileWaitingScreen">
      <h1>üöÄ Kosmiczna Matematyka</h1>

      <div
        id="mobileDebugInfo"
        style="
          color: #999;
          margin-bottom: 20px;
          font-size: 12px;
          font-family: monospace;
          text-align: left;
          max-width: 400px;
          width: 100%;
          padding: 10px;
          background: rgba(0, 0, 0, 0.3);
          border-radius: 5px;
          display: none;
        "
      >
        Debug info
      </div>

      <div class="status-message">
        <span id="mobileWaitingText">‚è≥ ≈ÅƒÖczenie...</span><br />
        <span class="loading">‚óè‚óè‚óè</span>
      </div>
    </div>

    <!-- Game Screen -->
    <div class="mobile-player-screen" id="mobileGameScreen">
      <div id="mobileTurnMessage" class="status-message"></div>
      <button type="button" class="mobile-btn roll" id="mobileRollBtn" disabled>
        üé≤ RZUƒÜ KOSTKƒÑ
      </button>
    </div>

    <!-- Question Screen -->
    <div class="mobile-player-screen" id="mobileQuestionScreen">
      <div class="question-box">
        <div class="timer" id="mobileTimer">0:00</div>
        <div class="question-text" id="mobileQuestionText"></div>
        <input
          type="number"
          id="mobileAnswerInput"
          placeholder="Wpisz odpowied≈∫"
          autocomplete="off"
          inputmode="numeric"
          pattern="[0-9]*"
        />
        <button type="button" class="mobile-btn" id="mobileSubmitBtn">
          ‚úì SPRAWD≈π
        </button>
      </div>
    </div>

    <!-- Winner Screen -->
    <div class="mobile-player-screen" id="mobileWinnerScreen">
      <h1>üèÜ KONIEC GRY! üèÜ</h1>
      <div class="success-message" id="mobileWinnerMessage"></div>

      <div id="mobileRematchVoting" style="display: none; margin-top: 30px">
        <h2 style="font-size: 28px; margin-bottom: 20px">
          üéÆ Zagraj ponownie?
        </h2>
        <div
          id="mobileRematchTimer"
          style="
            font-size: 48px;
            font-weight: bold;
            margin: 20px 0;
            color: #fff;
          "
        >
          15
        </div>
        <div
          id="mobileRematchVoteCount"
          style="font-size: 20px; margin: 20px 0"
        >
          0/4 graczy gotowych
        </div>
        <button
          type="button"
          class="mobile-btn"
          id="mobileRematchYesBtn"
          style="
            background: linear-gradient(135deg, #51cf66 0%, #40c057 100%);
            margin: 10px;
          "
        >
          ‚úì TAK
        </button>
        <button
          type="button"
          class="mobile-btn"
          id="mobileRematchNoBtn"
          style="
            background: linear-gradient(135deg, #ff6b6b 0%, #ee5a52 100%);
            margin: 10px;
          "
        >
          ‚úó NIE
        </button>
      </div>
    </div>

    <!-- Question Modal (Local Mode) -->
    <div class="question-modal" id="questionModal">
      <div class="question-content">
        <div class="question-timer" id="questionTimer">0:00</div>
        <h2 id="questionText"></h2>
        <input
          type="number"
          id="answerInput"
          placeholder="Wpisz odpowied≈∫"
          autocomplete="off"
        />
        <div class="correct-answer" id="correctAnswer"></div>
        <button id="checkAnswerBtn" onclick="checkAnswer()">‚úì SPRAWD≈π</button>
      </div>
    </div>

    <!-- Dice Animation -->
    <div class="dice-animation" id="diceAnimation">
      <div class="dice-number" id="diceNumber">6</div>
    </div>

    <!-- Temporary Notification -->
    <div class="temp-notification" id="tempNotification"></div>

    <script>
      // Player Profile System
      let playerProfile = {
        name: "",
        color: "",
      };

      // Create stars
      function createStars() {
        const starsContainer = document.getElementById("stars");
        for (let i = 0; i < 300; i++) {
          const star = document.createElement("div");
          star.className = "star";
          star.style.left = Math.random() * 100 + "%";
          star.style.top = Math.random() * 100 + "%";
          star.style.animationDelay = Math.random() * 3 + "s";
          starsContainer.appendChild(star);
        }
      }
      createStars();

      // ============================================
      // PLAYER PROFILE SYSTEM
      // ============================================

      function loadPlayerProfile() {
        const saved = localStorage.getItem("kosmicznaMatematykaProfile");
        if (saved) {
          try {
            playerProfile = JSON.parse(saved);
            return true;
          } catch (e) {}
        }
        return false;
      }

      function savePlayerProfile() {
        localStorage.setItem(
          "kosmicznaMatematykaProfile",
          JSON.stringify(playerProfile)
        );
      }

      function showProfileSetup() {
        document.getElementById("profileSetupScreen").style.display = "flex";

        // Setup event listeners for profile creation
        const nameInput = document.getElementById("profileNameInput");
        const createBtn = document.getElementById("createProfileBtn");
        const colorOptions = document.querySelectorAll(".profile-color-option");

        let selectedColor = "";

        // Color selection
        colorOptions.forEach((option) => {
          option.addEventListener("click", function () {
            colorOptions.forEach((o) => o.classList.remove("selected"));
            this.classList.add("selected");
            selectedColor = this.dataset.color;
            checkProfileReady();
          });
        });

        // Auto-select first color
        if (colorOptions[0]) {
          colorOptions[0].classList.add("selected");
          selectedColor = colorOptions[0].dataset.color;
        }

        // Name input
        nameInput.addEventListener("input", checkProfileReady);

        function checkProfileReady() {
          const hasName = nameInput.value.trim().length > 0;
          const hasColor = selectedColor !== "";
          createBtn.disabled = !(hasName && hasColor);
        }

        // Create profile button
        createBtn.addEventListener("click", function () {
          playerProfile.name = nameInput.value.trim();
          playerProfile.color = selectedColor;
          savePlayerProfile();

          document.getElementById("profileSetupScreen").style.display = "none";
          initGame();
        });

        checkProfileReady();
      }

      function showProfileEditButton() {
        const profileDisplay = document.getElementById("profileDisplay");
        const nameDisplay = document.getElementById("profileNameDisplay");
        const colorDot = document.getElementById("profileColorDot");
        const editBtn = document.getElementById("profileEditBtn");

        nameDisplay.textContent = playerProfile.name;
        colorDot.style.background = getPlayerColor(playerProfile.color);
        profileDisplay.style.display = "flex";

        // Setup edit button click (only once)
        if (!editBtn.dataset.initialized) {
          editBtn.dataset.initialized = "true";
          editBtn.addEventListener("click", openProfileEditModal);
        }
      }

      function hideProfileEditButton() {
        document.getElementById("profileDisplay").style.display = "none";
      }

      function openProfileEditModal() {
        const modal = document.getElementById("profileEditModal");
        const nameInput = document.getElementById("editProfileNameInput");
        const saveBtn = document.getElementById("saveProfileBtn");
        const cancelBtn = document.getElementById("cancelEditBtn");
        const colorOptions = document.querySelectorAll(".edit-color-option");

        // Set current values
        nameInput.value = playerProfile.name;

        // Select current color
        colorOptions.forEach((option) => {
          if (option.dataset.color === playerProfile.color) {
            option.classList.add("selected");
          } else {
            option.classList.remove("selected");
          }
        });

        let selectedColor = playerProfile.color;

        // Color selection
        colorOptions.forEach((option) => {
          option.addEventListener("click", function () {
            colorOptions.forEach((o) => o.classList.remove("selected"));
            this.classList.add("selected");
            selectedColor = this.dataset.color;
          });
        });

        // Save button
        saveBtn.onclick = function () {
          const newName = nameInput.value.trim();
          if (newName) {
            playerProfile.name = newName;
            playerProfile.color = selectedColor;
            savePlayerProfile();

            document.getElementById("profileNameDisplay").textContent =
              playerProfile.name;
            document.getElementById("profileColorDot").style.background =
              getPlayerColor(playerProfile.color);
            modal.style.display = "none";
          }
        };

        // Cancel button
        cancelBtn.onclick = function () {
          modal.style.display = "none";
        };

        modal.style.display = "flex";
      }

      function initGame() {
        // Show profile edit button in lobby
        showProfileEditButton();

        // Show main setup screen
        document.getElementById("setupScreen").style.display = "flex";
      }

      // Check if this is mobile player mode
      const urlParams = new URLSearchParams(window.location.search);
      const localRoomId = urlParams.get("room");
      const isMobilePlayer = !!localRoomId;

      if (isMobilePlayer) {
        // CRITICAL: Prevent multiple initializations
        if (window.mobileInitStarted) {
        } else {
          window.mobileInitStarted = true;

          // Hide desktop interface, show mobile waiting screen
          document.getElementById("setupScreen").style.display = "none";
          document
            .getElementById("mobileWaitingScreen")
            .classList.add("active");

          // Initialize immediately - no timeout needed
          if (document.readyState === "complete") {
            initMobilePlayer(localRoomId);
          } else {
            window.addEventListener("load", function () {
              initMobilePlayer(localRoomId);
            });
          }
        }
      } else {
        // Normal desktop mode - check profile first
        window.addEventListener("load", () => {
          if (loadPlayerProfile()) {
            // Profile exists, show game
            initGame();
            addPlayer();
          } else {
            // No profile, show profile setup
            showProfileSetup();
          }
        });
      }

      // Math problems
      const mathProblems = {
        white: [
          { q: "15+23", a: 38 },
          { q: "42-17", a: 25 },
          { q: "28+31", a: 59 },
          { q: "65-28", a: 37 },
          { q: "19+24", a: 43 },
          { q: "51-19", a: 32 },
          { q: "33+45", a: 78 },
          { q: "74-29", a: 45 },
          { q: "26+38", a: 64 },
          { q: "81-34", a: 47 },
          { q: "47+21", a: 68 },
          { q: "93-48", a: 45 },
          { q: "36+27", a: 63 },
          { q: "58-23", a: 35 },
          { q: "44+39", a: 83 },
          { q: "72-45", a: 27 },
          { q: "55+18", a: 73 },
          { q: "89-56", a: 33 },
          { q: "24+38", a: 62 },
          { q: "67-29", a: 38 },
          { q: "41+52", a: 93 },
          { q: "85-37", a: 48 },
          { q: "29+46", a: 75 },
          { q: "76-48", a: 28 },
        ],
        green: [
          { q: "3√ó4", a: 12 },
          { q: "12√∑3", a: 4 },
          { q: "5√ó6", a: 30 },
          { q: "24√∑4", a: 6 },
          { q: "7√ó3", a: 21 },
          { q: "18√∑6", a: 3 },
          { q: "4√ó8", a: 32 },
          { q: "36√∑9", a: 4 },
          { q: "6√ó5", a: 30 },
          { q: "35√∑7", a: 5 },
          { q: "8√ó4", a: 32 },
          { q: "28√∑7", a: 4 },
          { q: "9√ó3", a: 27 },
          { q: "45√∑5", a: 9 },
          { q: "7√ó6", a: 42 },
          { q: "48√∑8", a: 6 },
          { q: "5√ó9", a: 45 },
          { q: "54√∑6", a: 9 },
          { q: "8√ó7", a: 56 },
          { q: "63√∑7", a: 9 },
          { q: "6√ó9", a: 54 },
          { q: "72√∑8", a: 9 },
          { q: "4√ó7", a: 28 },
          { q: "32√∑4", a: 8 },
        ],
        yellow: [
          { q: "11√ó6", a: 66 },
          { q: "84√∑12", a: 7 },
          { q: "13√ó5", a: 65 },
          { q: "78√∑6", a: 13 },
          { q: "12√ó7", a: 84 },
          { q: "96√∑8", a: 12 },
          { q: "14√ó6", a: 84 },
          { q: "91√∑7", a: 13 },
          { q: "15√ó4", a: 60 },
          { q: "72√∑12", a: 6 },
          { q: "11√ó8", a: 88 },
          { q: "99√∑11", a: 9 },
          { q: "13√ó6", a: 78 },
          { q: "84√∑7", a: 12 },
          { q: "12√ó9", a: 108 },
          { q: "108√∑9", a: 12 },
          { q: "14√ó5", a: 70 },
          { q: "77√∑11", a: 7 },
          { q: "15√ó6", a: 90 },
          { q: "88√∑8", a: 11 },
          { q: "16√ó5", a: 80 },
          { q: "96√∑6", a: 16 },
          { q: "17√ó4", a: 68 },
          { q: "85√∑5", a: 17 },
        ],
        red: [
          { q: "17√ó8", a: 136 },
          { q: "144√∑12", a: 12 },
          { q: "23√ó6", a: 138 },
          { q: "156√∑13", a: 12 },
          { q: "19√ó9", a: 171 },
          { q: "168√∑14", a: 12 },
          { q: "21√ó8", a: 168 },
          { q: "195√∑15", a: 13 },
          { q: "24√ó7", a: 168 },
          { q: "192√∑16", a: 12 },
          { q: "26√ó7", a: 182 },
          { q: "204√∑17", a: 12 },
          { q: "18√ó11", a: 198 },
          { q: "216√∑18", a: 12 },
          { q: "22√ó9", a: 198 },
          { q: "228√∑19", a: 12 },
          { q: "25√ó8", a: 200 },
          { q: "240√∑20", a: 12 },
          { q: "27√ó7", a: 189 },
          { q: "252√∑21", a: 12 },
          { q: "29√ó6", a: 174 },
          { q: "264√∑22", a: 12 },
          { q: "31√ó5", a: 155 },
          { q: "276√∑23", a: 12 },
        ],
      };

      // Generate board path
      function generateBoardPath() {
        const path = [];
        const cols = 16;
        const rows = 10;
        const startX = 60;
        const startY = 80;
        const spaceX = 45;
        const spaceY = 50;
        let lastQuestionIndex = -10;

        for (let row = 0; row < rows; row++) {
          for (let col = 0; col < cols; col++) {
            let x, y;
            let arrow = null;
            const currentIndex = row * cols + col;

            if (row % 2 === 0) {
              x = startX + col * spaceX;
              if (col > 0 && col < cols - 1 && col % 4 === 0) {
                arrow = "‚Üí";
              }
            } else {
              x = startX + (cols - 1 - col) * spaceX;
              if (col > 0 && col < cols - 1 && col % 4 === 0) {
                arrow = "‚Üê";
              }
            }

            y = startY + row * spaceY;

            if (row % 2 === 0 && col === cols - 1 && row < rows - 1) {
              arrow = "‚Üì";
            }
            if (row % 2 === 1 && col === 0 && row < rows - 1) {
              arrow = "‚Üì";
            }

            let color = "white";

            if (currentIndex > 0 && currentIndex < cols * rows - 1) {
              if (currentIndex - lastQuestionIndex >= 2) {
                const rand = Math.random();
                if (rand < 0.85) {
                  const questionRand = Math.random();
                  if (questionRand < 0.45) {
                    color = "green";
                  } else if (questionRand < 0.8) {
                    color = "yellow";
                  } else {
                    color = "red";
                  }
                  lastQuestionIndex = currentIndex;
                }
              }
            }

            path.push({ x, y, color, arrow });
          }
        }

        const teleportPositions = [
          { from: 24, to: 45, arrow: "‚Æï" },
          { from: 68, to: 95, arrow: "‚Æï" },
          { from: 110, to: 138, arrow: "‚Æï" },
        ];

        teleportPositions.forEach((tp) => {
          if (tp.from < path.length && tp.to < path.length) {
            path[tp.from].color = "purple";
            path[tp.from].arrow = tp.arrow;
            path[tp.from].teleportTo = tp.to;
            shortcuts.push({ from: tp.from, to: tp.to });
          }
        });

        return path;
      }

      const shortcuts = [];
      const boardPath = generateBoardPath();

      // Game state
      let gamePlayers = [];
      let currentPlayer = 0;
      let playerPositions = [];
      let playerPieces = [];
      let currentQuestion = null;
      let currentDifficulty = null;
      let usedProblems = { white: [], green: [], yellow: [], red: [] };
      let bonusRollInTurn = false;
      let questionTimer = null;
      let questionTimeLeft = 0;

      // Online mode variables
      let isOnlineMode = false;
      let isHost = false;
      let peer = null;
      let connections = [];
      let onlineRoomId = null;
      let onlinePlayers = [];

      // Rematch voting
      let rematchVotes = new Map(); // conn.peer -> true/false
      let rematchTimer = null;
      let rematchTimeLeft = 15;

      // Mobile player variables
      let myPeer = null;
      let hostConnection = null;
      let myPlayerName = "";
      let myPlayerColor = "";
      let allPlayers = [];
      let currentTurn = 0;
      let mobileQuestionTimer = null;
      let mobileInitialized = false;
      let lastTurnMessageHTML = "";
      let roomId = null; // Room ID for mobile player
      let isAnsweringQuestion = false; // Track if player is currently answering

      // =====  LOCAL MODE FUNCTIONS =====

      let playerCount = 0;
      const usedColors = new Set();
      const usedNames = new Set();

      function addPlayer() {
        if (playerCount >= 4) return;

        playerCount++;
        const container = document.getElementById("playersContainer");
        const playerSetup = document.createElement("div");
        playerSetup.className = "player-setup";
        playerSetup.id = `player${playerCount}Setup`;

        const colors = [
          { name: "blue", hex: "#4dabf7" },
          { name: "red", hex: "#ff6b6b" },
          { name: "green", hex: "#51cf66" },
          { name: "yellow", hex: "#ffd43b" },
          { name: "purple", hex: "#9b59b6" },
          { name: "orange", hex: "#ff922b" },
          { name: "pink", hex: "#ff6ba9" },
          { name: "cyan", hex: "#22b8cf" },
        ];

        playerSetup.innerHTML = `
          <h3>Gracz ${playerCount}</h3>
          <input type="text" id="player${playerCount}Name" placeholder="Wpisz imiƒô" oninput="validateNames()" />
          <div class="error-message" id="player${playerCount}Error">To imiƒô jest ju≈º zajƒôte!</div>
          <div class="color-selector" id="colors${playerCount}">
            ${colors
              .map(
                (c) =>
                  `<div class="color-option" style="background: ${c.hex};" data-color="${c.name}" onclick="selectColor(${playerCount}, '${c.name}')"></div>`
              )
              .join("")}
          </div>
        `;

        container.appendChild(playerSetup);
        colors[0] && selectColor(playerCount, colors[0].name);

        if (playerCount >= 4) {
          document.getElementById("addPlayerBtn").disabled = true;
        }

        updateStartButton();
        updateColorOptions();
      }

      function selectColor(playerNum, color) {
        if (usedColors.has(color)) return;

        const previousColor = gamePlayers.find(
          (p) => p.num === playerNum
        )?.color;
        if (previousColor) {
          usedColors.delete(previousColor);
        }

        usedColors.add(color);
        gamePlayers = gamePlayers.filter((p) => p.num !== playerNum);

        const name =
          document.getElementById(`player${playerNum}Name`).value ||
          `Gracz ${playerNum}`;
        gamePlayers.push({ num: playerNum, name: name, color: color });

        updateColorOptions();
        updateStartButton();
      }

      function updateColorOptions() {
        for (let i = 1; i <= playerCount; i++) {
          const setup = document.getElementById(`player${i}Setup`);
          if (!setup) continue;

          const options = setup.querySelectorAll(".color-option");
          options.forEach((option) => {
            const color = option.dataset.color;
            const isSelected =
              gamePlayers.find((p) => p.num === i)?.color === color;
            const isUsed = usedColors.has(color) && !isSelected;

            option.classList.toggle("selected", isSelected);
            option.classList.toggle("disabled", isUsed);
          });
        }
      }

      function validateNames() {
        usedNames.clear();
        let allValid = true;

        for (let i = 1; i <= playerCount; i++) {
          const input = document.getElementById(`player${i}Name`);
          const error = document.getElementById(`player${i}Error`);
          if (!input) continue;

          const name = input.value.trim().toLowerCase();

          if (name && usedNames.has(name)) {
            input.classList.add("error");
            error.classList.add("show");
            allValid = false;
          } else {
            input.classList.remove("error");
            error.classList.remove("show");
            if (name) {
              usedNames.add(name);
            }
          }
        }

        return allValid;
      }

      function updateStartButton() {
        const namesValid = validateNames();

        const validPlayers = gamePlayers.filter((p) => {
          const name = document.getElementById(`player${p.num}Name`)?.value;
          return name && name.trim() !== "" && p.color;
        });

        document.getElementById("startGameBtn").disabled =
          validPlayers.length < 2 || !namesValid;
      }

      document.addEventListener("input", (e) => {
        if (e.target.matches('[id^="player"][id$="Name"]')) {
          const playerNum = parseInt(e.target.id.match(/\d+/)[0]);
          const existingPlayer = gamePlayers.find((p) => p.num === playerNum);
          if (existingPlayer) {
            existingPlayer.name = e.target.value || `Gracz ${playerNum}`;
          }
          updateStartButton();
        }
      });

      function startGame() {
        hideProfileEditButton();

        if (!validateNames()) {
          alert("Ka≈ºdy gracz musi mieƒá unikalnƒÖ nazwƒô!");
          return;
        }

        gamePlayers = gamePlayers.filter((p) => {
          const name = document.getElementById(`player${p.num}Name`)?.value;
          return name && name.trim() !== "" && p.color;
        });

        if (gamePlayers.length < 2) {
          alert("Potrzebujesz co najmniej 2 graczy!");
          return;
        }

        gamePlayers.sort((a, b) => a.num - b.num);
        playerPositions = new Array(gamePlayers.length).fill(0);

        document.getElementById("setupScreen").style.display = "none";
        document.getElementById("gameScreen").style.display = "block";
        document.getElementById("localControls").style.display = "block";

        initBoard();
      }

      function initBoard() {
        const board = document.getElementById("board");

        // Clear previous content except markers and instructions
        const markers = board.querySelectorAll(
          ".start-marker, .finish-marker, .instructions-toggle, .instructions-panel"
        );
        board.innerHTML = "";
        markers.forEach((m) => board.appendChild(m));

        const svg = document.createElementNS(
          "http://www.w3.org/2000/svg",
          "svg"
        );
        svg.style.position = "absolute";
        svg.style.top = "0";
        svg.style.left = "0";
        svg.style.width = "100%";
        svg.style.height = "100%";
        svg.style.pointerEvents = "none";
        svg.style.zIndex = "5";
        board.appendChild(svg);

        for (let i = 0; i < boardPath.length - 1; i++) {
          const current = boardPath[i];
          const next = boardPath[i + 1];

          const line = document.createElementNS(
            "http://www.w3.org/2000/svg",
            "line"
          );
          line.setAttribute("x1", current.x + 20);
          line.setAttribute("y1", current.y + 20);
          line.setAttribute("x2", next.x + 20);
          line.setAttribute("y2", next.y + 20);
          line.setAttribute("class", "path-line");
          svg.appendChild(line);
        }

        shortcuts.forEach((shortcut) => {
          const fromSpace = boardPath[shortcut.from];
          const toSpace = boardPath[shortcut.to];

          const line = document.createElementNS(
            "http://www.w3.org/2000/svg",
            "line"
          );
          line.setAttribute("x1", fromSpace.x + 20);
          line.setAttribute("y1", fromSpace.y + 20);
          line.setAttribute("x2", toSpace.x + 20);
          line.setAttribute("y2", toSpace.y + 20);
          line.setAttribute("class", "teleport-line");
          svg.appendChild(line);
        });

        boardPath.forEach((space, index) => {
          const spaceElement = document.createElement("div");
          spaceElement.className = `space ${space.color}`;
          spaceElement.style.left = space.x + "px";
          spaceElement.style.top = space.y + "px";

          if (index === 0) {
            spaceElement.textContent = "üöÄ";
          } else if (index === boardPath.length - 1) {
            spaceElement.textContent = "üèÅ";
          } else if (space.arrow) {
            spaceElement.textContent = space.arrow;
          }

          board.appendChild(spaceElement);
        });

        playerPieces = [];
        gamePlayers.forEach((player, index) => {
          const piece = document.createElement("div");
          piece.className = "player-piece";
          piece.style.background = getPlayerColor(player.color);
          piece.id = `playerPiece${index}`;
          board.appendChild(piece);
          playerPieces.push(piece);
          updatePlayerPosition(index);
        });

        updateCurrentPlayerDisplay();
      }

      function getPlayerColor(color) {
        const colors = {
          blue: "#4dabf7",
          red: "#ff6b6b",
          green: "#51cf66",
          yellow: "#ffd43b",
          purple: "#9b59b6",
          orange: "#ff922b",
          pink: "#ff6ba9",
          cyan: "#22b8cf",
        };
        return colors[color] || "#4dabf7";
      }

      function updatePlayerPosition(playerIndex) {
        const position = playerPositions[playerIndex];
        const piece = playerPieces[playerIndex];
        if (!piece) return;

        if (position >= boardPath.length) {
          const space = boardPath[boardPath.length - 1];
          piece.style.left = space.x + 5 + "px";
          piece.style.top = space.y + 5 + "px";
          return;
        }

        if (position < 0) {
          playerPositions[playerIndex] = 0;
          updatePlayerPosition(playerIndex);
          return;
        }

        const space = boardPath[position];
        const uniqueOffset = playerIndex * 6;
        piece.style.left = space.x + 5 + uniqueOffset + "px";
        piece.style.top = space.y + 5 + uniqueOffset + "px";
      }

      function playJumpSound() {
        const audioContext = new (window.AudioContext ||
          window.webkitAudioContext)();
        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();

        oscillator.connect(gainNode);
        gainNode.connect(audioContext.destination);

        oscillator.frequency.value = 150;
        oscillator.type = "triangle";

        gainNode.gain.setValueAtTime(0.4, audioContext.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(
          0.01,
          audioContext.currentTime + 0.08
        );

        oscillator.start(audioContext.currentTime);
        oscillator.stop(audioContext.currentTime + 0.08);
      }

      function animatePlayerMovement(
        playerIndex,
        fromPosition,
        toPosition,
        callback
      ) {
        if (fromPosition === toPosition) {
          if (callback) callback();
          return;
        }

        const direction = toPosition > fromPosition ? 1 : -1;
        let currentPos = fromPosition;
        const piece = playerPieces[playerIndex];

        function moveOneStep() {
          if (
            (direction > 0 && currentPos >= toPosition) ||
            (direction < 0 && currentPos <= toPosition)
          ) {
            playerPositions[playerIndex] = toPosition;
            updatePlayerPosition(playerIndex);
            if (callback) callback();
            return;
          }

          currentPos += direction;
          playerPositions[playerIndex] = currentPos;
          updatePlayerPosition(playerIndex);
          playJumpSound();

          if (piece) {
            piece.style.transform = "scale(1.3)";
            setTimeout(() => {
              piece.style.transform = "scale(1)";
            }, 100);
          }

          setTimeout(moveOneStep, 200);
        }

        moveOneStep();
      }

      function updateCurrentPlayerDisplay() {
        const player = gamePlayers[currentPlayer];
        const display = document.getElementById("currentPlayer");
        if (display) {
          display.innerHTML = `Tura: <span style="color: ${getPlayerColor(
            player.color
          )}; text-shadow: 0 0 15px ${getPlayerColor(player.color)};">${
            player.name
          }</span>`;
        }
      }

      let diceRolling = false;

      function rollDice() {
        if (diceRolling) return;

        diceRolling = true;
        const rollBtn = document.getElementById("rollDiceBtn");
        if (rollBtn) rollBtn.disabled = true;

        const playerIndex = currentPlayer;
        const result = Math.floor(Math.random() * 6) + 1;
        playDiceSound();
        showDiceAnimation(result);

        const diceResultEl = document.getElementById("diceResult");
        if (diceResultEl) {
          diceResultEl.textContent = `Wyrzucono: ${result}`;
        }

        setTimeout(() => {
          const oldPosition = playerPositions[playerIndex];
          const newPosition = Math.min(oldPosition + result, boardPath.length);

          animatePlayerMovement(playerIndex, oldPosition, newPosition, () => {
            diceRolling = false;
            if (rollBtn) rollBtn.disabled = false;

            if (playerPositions[playerIndex] >= boardPath.length) {
              setTimeout(() => {
                startFireworks();
                showNotification(
                  `üéâüèÜ ${gamePlayers[playerIndex].name} WYGRYWA! üèÜüéâ`,
                  "success"
                );
                setTimeout(() => location.reload(), 3000);
              }, 500);
              return;
            }

            setTimeout(() => {
              checkSpaceAndAskQuestion();
            }, 300);
          });
        }, 1000);
      }

      function playDiceSound() {
        const audioContext = new (window.AudioContext ||
          window.webkitAudioContext)();

        for (let i = 0; i < 8; i++) {
          setTimeout(() => {
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();

            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);

            oscillator.frequency.value = 100 + Math.random() * 200;
            oscillator.type = "square";

            gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(
              0.01,
              audioContext.currentTime + 0.05
            );

            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + 0.05);
          }, i * 100);
        }
      }

      function showDiceAnimation(result) {
        const diceEl = document.getElementById("diceAnimation");
        const numberEl = document.getElementById("diceNumber");

        diceEl.style.display = "block";

        let count = 0;
        const interval = setInterval(() => {
          numberEl.textContent = Math.floor(Math.random() * 6) + 1;
          count++;
          if (count > 10) {
            clearInterval(interval);
            numberEl.textContent = result;
          }
        }, 80);

        setTimeout(() => {
          diceEl.style.display = "none";
        }, 1000);
      }

      function checkSpaceAndAskQuestion() {
        const playerIndex = currentPlayer;

        if (
          playerPositions[playerIndex] > 0 &&
          playerPositions[playerIndex] < boardPath.length
        ) {
          const spaceColor = boardPath[playerPositions[playerIndex]].color;

          if (
            spaceColor === "purple" ||
            spaceColor === "green" ||
            spaceColor === "yellow" ||
            spaceColor === "red" ||
            spaceColor === "white"
          ) {
            askQuestion(spaceColor);
          } else {
            nextPlayer();
          }
        } else {
          nextPlayer();
        }
      }

      function drawCard(difficulty) {
        let deckId = "";
        if (difficulty === "white") {
          deckId = "whiteDeck";
        } else if (difficulty === "green") {
          deckId = "greenDeck";
        } else if (difficulty === "yellow") {
          deckId = "yellowDeck";
        } else if (difficulty === "red" || difficulty === "purple") {
          deckId = "redDeck";
        }

        if (!deckId) return;

        const deck = document.getElementById(deckId);
        if (!deck) return;

        const card = deck.querySelector(".deck-card");
        if (!card) return;

        const animCard = card.cloneNode(true);
        animCard.classList.add("card-drawing");
        deck.appendChild(animCard);

        setTimeout(() => {
          animCard.remove();
        }, 1200);
      }

      function askQuestion(difficulty) {
        currentDifficulty = difficulty;

        drawCard(difficulty);

        setTimeout(() => {
          const problemDifficulty =
            difficulty === "purple" ? "red" : difficulty;
          const problems = mathProblems[problemDifficulty];

          let problem;
          let attempts = 0;
          do {
            problem = problems[Math.floor(Math.random() * problems.length)];
            attempts++;
          } while (
            usedProblems[problemDifficulty].includes(problem.q) &&
            attempts < 50
          );

          if (attempts >= 50) {
            usedProblems[problemDifficulty] = [];
            problem = problems[Math.floor(Math.random() * problems.length)];
          }

          usedProblems[problemDifficulty].push(problem.q);
          currentQuestion = problem;

          const levelNames = {
            white: "DODAWANIE/ODEJMOWANIE ‚ö™",
            green: "≈ÅATWE üü¢",
            yellow: "≈öREDNIE üü°",
            red: "TRUDNE üî¥",
            purple: "TELEPORT üü£ - TRUDNE PYTANIE!",
          };

          document.getElementById(
            "questionText"
          ).textContent = `${levelNames[difficulty]}: ${problem.q} = ?`;
          document.getElementById("answerInput").value = "";
          document.getElementById(
            "correctAnswer"
          ).textContent = `Poprawna odpowied≈∫: ${problem.a}`;
          document.getElementById("correctAnswer").style.display = "none";

          document.getElementById("questionModal").style.display = "flex";
          document.getElementById("answerInput").focus();

          startQuestionTimer();
        }, 800);
      }

      let checkingAnswer = false;

      function checkAnswer() {
        if (checkingAnswer) return;

        checkingAnswer = true;
        const checkBtn = document.getElementById("checkAnswerBtn");
        if (checkBtn) checkBtn.disabled = true;

        const playerIndex = currentPlayer;

        stopQuestionTimer();

        const userAnswer = parseInt(
          document.getElementById("answerInput").value
        );
        const correctAnswerEl = document.getElementById("correctAnswer");
        correctAnswerEl.style.display = "block";

        if (userAnswer === currentQuestion.a) {
          let movement = 0;
          let message = "";
          let giveBonus = false;
          let teleport = false;
          let teleportTo = null;

          if (currentDifficulty === "white") {
            movement = 0;
            message = "‚úì DOBRZE!\nZostajesz w miejscu!";
          } else if (currentDifficulty === "purple") {
            const currentSpace = boardPath[playerPositions[playerIndex]];
            if (currentSpace.teleportTo !== undefined) {
              teleport = true;
              teleportTo = currentSpace.teleportTo;
              message = "‚úì DOBRZE!\nüöÄ TELEPORTACJA!";
            }
          } else if (currentDifficulty === "green") {
            movement = 1;
            message = "‚úì DOBRZE! +1 pole";
          } else if (currentDifficulty === "yellow") {
            movement = 2;
            if (!bonusRollInTurn) {
              message = "‚úì DOBRZE! +2 pola\nüé≤ BONUS: Rzuƒá jeszcze raz!";
              giveBonus = true;
            } else {
              message = "‚úì DOBRZE! +2 pola\n(Maksymalnie 2 rzuty w turze)";
            }
          } else if (currentDifficulty === "red") {
            movement = 3;
            if (!bonusRollInTurn) {
              message = "‚úì DOBRZE! +3 pola\nüé≤ BONUS: Rzuƒá jeszcze raz!";
              giveBonus = true;
            } else {
              message = "‚úì DOBRZE! +3 pola\n(Maksymalnie 2 rzuty w turze)";
            }
          }

          showNotification(message, "success");

          setTimeout(() => {
            document.getElementById("questionModal").style.display = "none";
            correctAnswerEl.style.display = "none";

            const oldPosition = playerPositions[playerIndex];
            let newPosition;

            if (teleport) {
              newPosition = Math.min(teleportTo, boardPath.length);
            } else {
              newPosition = Math.min(oldPosition + movement, boardPath.length);
            }

            animatePlayerMovement(playerIndex, oldPosition, newPosition, () => {
              if (playerPositions[playerIndex] >= boardPath.length) {
                setTimeout(() => {
                  startFireworks();
                  showNotification(
                    `üéâüèÜ ${gamePlayers[playerIndex].name} WYGRYWA! üèÜüéâ`,
                    "success"
                  );
                  setTimeout(() => location.reload(), 3000);
                }, 500);
                return;
              }

              checkingAnswer = false;
              if (checkBtn) checkBtn.disabled = false;

              if (giveBonus) {
                bonusRollInTurn = true;
                setTimeout(() => {
                  showNotification(
                    "üé≤ Twoja kolej - rzuƒá jeszcze raz!",
                    "success"
                  );
                }, 500);
              } else {
                bonusRollInTurn = false;
                nextPlayer();
              }
            });
          }, 2000);
        } else {
          let movement = 0;
          let message = "";

          if (currentDifficulty === "white") {
            movement = -4;
            message = `‚úó ≈πLE! Poprawna: ${currentQuestion.a}\nCofasz siƒô 4 pola!`;
          } else if (currentDifficulty === "purple") {
            movement = 0;
            message = `‚úó ≈πLE! Poprawna: ${currentQuestion.a}\nZostajesz na miejscu!`;
          } else if (currentDifficulty === "green") {
            movement = -3;
            message = `‚úó ≈πLE! Poprawna: ${currentQuestion.a}\nCofasz siƒô 3 pola!`;
          } else if (currentDifficulty === "yellow") {
            movement = -2;
            message = `‚úó ≈πLE! Poprawna: ${currentQuestion.a}\nCofasz siƒô 2 pola!`;
          } else if (currentDifficulty === "red") {
            movement = -1;
            message = `‚úó ≈πLE! Poprawna: ${currentQuestion.a}\nCofasz siƒô 1 pole!`;
          }

          showNotification(message, "error");

          setTimeout(() => {
            document.getElementById("questionModal").style.display = "none";
            correctAnswerEl.style.display = "none";

            const oldPosition = playerPositions[playerIndex];
            const newPosition = Math.max(0, oldPosition + movement);

            animatePlayerMovement(playerIndex, oldPosition, newPosition, () => {
              bonusRollInTurn = false;
              nextPlayer();
            });

            checkingAnswer = false;
            if (checkBtn) checkBtn.disabled = false;
          }, 2000);
        }
      }

      function showNotification(message, type) {
        const notification = document.getElementById("tempNotification");
        notification.textContent = message;
        notification.className = `temp-notification ${type}`;
        notification.style.display = "block";

        setTimeout(() => {
          notification.style.display = "none";
        }, 2000);
      }

      document.addEventListener("keypress", (e) => {
        if (
          e.key === "Enter" &&
          document.getElementById("questionModal").style.display === "flex"
        ) {
          checkAnswer();
        }
      });

      function getQuestionTimeLimit(difficulty) {
        const limits = {
          white: 30,
          green: 30,
          yellow: 60,
          red: 90,
          purple: 90,
        };
        return limits[difficulty] || 60;
      }

      function startQuestionTimer() {
        if (questionTimer) {
          clearInterval(questionTimer);
        }

        const timeLimit = getQuestionTimeLimit(currentDifficulty);
        questionTimeLeft = timeLimit;

        updateTimerDisplay();

        questionTimer = setInterval(() => {
          questionTimeLeft--;
          updateTimerDisplay();

          if (questionTimeLeft <= 0) {
            clearInterval(questionTimer);
            handleTimeOut();
          }
        }, 1000);
      }

      function updateTimerDisplay() {
        const timerEl = document.getElementById("questionTimer");
        if (!timerEl) return;

        const minutes = Math.floor(questionTimeLeft / 60);
        const seconds = questionTimeLeft % 60;
        timerEl.textContent = `${minutes}:${seconds
          .toString()
          .padStart(2, "0")}`;

        timerEl.classList.remove("warning", "danger");

        const timeLimit = getQuestionTimeLimit(currentDifficulty);
        if (questionTimeLeft <= 10) {
          timerEl.classList.add("danger");
        } else if (questionTimeLeft <= timeLimit / 3) {
          timerEl.classList.add("warning");
        }
      }

      function stopQuestionTimer() {
        if (questionTimer) {
          clearInterval(questionTimer);
          questionTimer = null;
        }
      }

      function handleTimeOut() {
        showNotification(`‚è∞ CZAS MINƒÑ≈Å!`, "error");

        setTimeout(() => {
          document.getElementById("answerInput").value = "999999";
          checkAnswer();
        }, 1000);
      }

      function nextPlayer() {
        bonusRollInTurn = false;
        currentPlayer = (currentPlayer + 1) % gamePlayers.length;
        updateCurrentPlayerDisplay();
      }

      function toggleInstructions() {
        const panel = document.getElementById("instructionsPanel");
        panel.classList.toggle("open");
      }

      // ===== ONLINE MODE - HOST =====

      function generateRoomId() {
        return "room_" + Math.random().toString(36).substr(2, 9);
      }

      function openOnlineMode() {
        if (typeof Peer === "undefined") {
          alert(
            "Biblioteka PeerJS nie zosta≈Ça za≈Çadowana. Sprawd≈∫ po≈ÇƒÖczenie internetowe i od≈õwie≈º stronƒô."
          );
          return;
        }

        isOnlineMode = true;
        isHost = true;

        onlineRoomId = generateRoomId();

        try {
          peer = new Peer(onlineRoomId);
        } catch (error) {
          alert("Nie mo≈ºna uruchomiƒá trybu online: " + error.message);
          return;
        }

        peer.on("open", function (id) {
          document.getElementById("onlineStatusText").textContent =
            "Zeskanuj kod QR telefonem!";

          const currentUrl = window.location.href.split("?")[0];
          const playerUrl = currentUrl + "?room=" + onlineRoomId;

          document.getElementById("qrcode").innerHTML = "";

          if (typeof QRCode === "undefined") {
            document.getElementById("qrcode").innerHTML =
              '<div style="color: #333; padding: 20px; text-align: left;"><strong>Kod pokoju:</strong><br>' +
              onlineRoomId +
              "<br><br><strong>Link dla graczy:</strong><br><small>" +
              playerUrl +
              "</small></div>";
          } else {
            try {
              new QRCode(document.getElementById("qrcode"), {
                text: playerUrl,
                width: 256,
                height: 256,
              });
            } catch (error) {
              document.getElementById("qrcode").innerHTML =
                '<div style="color: #333; padding: 20px;">Link: ' +
                playerUrl +
                "</div>";
            }
          }

          document.getElementById("onlineLobby").style.display = "flex";
        });

        peer.on("connection", function (conn) {
          connections.push(conn);

          conn.on("data", function (data) {
            handlePlayerMessage(conn, data);
          });

          conn.on("close", function () {
            connections = connections.filter((c) => c !== conn);
            onlinePlayers = onlinePlayers.filter((p) => p.conn !== conn);
            updatePlayersWaitingList();
          });
        });

        peer.on("error", function (err) {
          if (err.type === "unavailable-id") {
            alert("Pok√≥j jest ju≈º zajƒôty. Spr√≥buj ponownie.");
            closeOnlineMode();
          } else if (err.type === "network") {
            alert("B≈ÇƒÖd sieci. Sprawd≈∫ po≈ÇƒÖczenie internetowe.");
          } else {
            alert("B≈ÇƒÖd po≈ÇƒÖczenia: " + err.type);
          }
        });
      }

      function closeOnlineMode() {
        if (peer) {
          peer.destroy();
        }
        connections = [];
        onlinePlayers = [];
        isOnlineMode = false;
        isHost = false;
        document.getElementById("onlineLobby").style.display = "none";
        document.getElementById("qrcode").innerHTML = "";
      }

      function handlePlayerMessage(conn, data) {
        if (data.type === "join") {
          // Check if max players reached
          if (onlinePlayers.length >= 4) {
            conn.send({
              type: "error",
              message: "Gra jest pe≈Çna! (max 4 graczy)",
            });
            return;
          }

          // Check if player already exists
          const existingPlayer = onlinePlayers.find((p) => p.conn === conn);
          if (!existingPlayer) {
            let playerColor = data.color;

            // Check if color is already taken
            const colorTaken = onlinePlayers.some(
              (p) => p.color === playerColor
            );
            if (colorTaken) {
              // Assign random available color
              const allColors = [
                "blue",
                "red",
                "green",
                "yellow",
                "purple",
                "orange",
                "pink",
                "cyan",
              ];
              const takenColors = onlinePlayers.map((p) => p.color);
              const availableColors = allColors.filter(
                (c) => !takenColors.includes(c)
              );

              if (availableColors.length > 0) {
                playerColor =
                  availableColors[
                    Math.floor(Math.random() * availableColors.length)
                  ];
              } else {
                conn.send({
                  type: "error",
                  message: "Brak dostƒôpnych kolor√≥w!",
                });
                return;
              }
            }

            onlinePlayers.push({
              conn: conn,
              name: data.name,
              color: playerColor,
              id: conn.peer,
            });
            updatePlayersWaitingList();

            // Send success to this player with assigned color
            conn.send({
              type: "joined",
              success: true,
              assignedColor: playerColor,
            });
          }
        } else if (data.type === "roll") {
          if (isCurrentPlayerTurn(conn)) {
            rollDiceOnline();
          }
        } else if (data.type === "answerUpdate") {
          if (isCurrentPlayerTurn(conn)) {
            // Update answer display on host in real-time (without color)
            updateQuestionModalAnswer(data.answer);
          }
        } else if (data.type === "answer") {
          if (isCurrentPlayerTurn(conn)) {
            submitAnswerOnline(data.answer);
          }
        } else if (data.type === "cheat") {
          if (isCurrentPlayerTurn(conn)) {
            handleCheatOnline(conn, data.reason);
          }
        } else if (data.type === "rematchVote") {
          handleRematchVote(conn, data.vote);
        }
      }

      function isCurrentPlayerTurn(conn) {
        if (!gamePlayers.length || !isOnlineMode) return false;
        const currentPlayerConn = gamePlayers[currentPlayer].conn;
        return currentPlayerConn === conn;
      }

      function updatePlayersWaitingList() {
        const list = document.getElementById("playersWaitingList");
        if (onlinePlayers.length === 0) {
          list.innerHTML = '<p style="color: #999;">Czekam na graczy...</p>';
        } else {
          list.innerHTML = onlinePlayers
            .map(
              (p) => `
            <div class="player-item">
              <div class="player-color-dot" style="background: ${getPlayerColor(
                p.color
              )};"></div>
              <strong>${p.name}</strong>
            </div>
          `
            )
            .join("");
        }

        const startBtn = document.getElementById("startOnlineBtn");
        if (onlinePlayers.length >= 2 && onlinePlayers.length <= 4) {
          startBtn.disabled = false;
          startBtn.textContent = `üéÆ START GRY (${onlinePlayers.length} ${
            onlinePlayers.length === 1
              ? "gracz"
              : onlinePlayers.length < 5
              ? "graczy"
              : "graczy"
          })`;
        } else if (onlinePlayers.length === 1) {
          startBtn.disabled = true;
          startBtn.textContent = `Czekam na wiƒôcej graczy... (1/2)`;
        } else {
          startBtn.disabled = true;
          startBtn.textContent = `üéÆ START GRY (min. 2 graczy)`;
        }
      }

      function startOnlineGame() {
        if (onlinePlayers.length < 2 || onlinePlayers.length > 4) {
          alert("Potrzeba 2-4 graczy!");
          return;
        }

        gamePlayers = onlinePlayers.map((p, idx) => ({
          num: idx + 1,
          name: p.name,
          color: p.color,
          conn: p.conn,
        }));

        playerPositions = new Array(gamePlayers.length).fill(0);

        document.getElementById("onlineLobby").style.display = "none";
        document.getElementById("setupScreen").style.display = "none";
        document.getElementById("gameScreen").style.display = "block";
        document.getElementById("localControls").style.display = "none";

        initBoard();

        broadcastToPlayers({
          type: "gameStart",
          players: gamePlayers.map((p) => ({ name: p.name, color: p.color })),
          currentPlayer: 0,
        });

        notifyPlayerTurn(0);
      }

      function notifyPlayerTurn(playerIndex) {
        currentPlayer = playerIndex;
        const player = gamePlayers[playerIndex];

        broadcastToPlayers({
          type: "turnUpdate",
          currentPlayer: playerIndex,
        });

        if (player.conn) {
          player.conn.send({
            type: "yourTurn",
            canRoll: true,
          });
        }
      }

      function rollDiceOnline() {
        const playerIndex = currentPlayer;
        const result = Math.floor(Math.random() * 6) + 1;

        // Send dice result to players (they will show animation)
        broadcastToPlayers({
          type: "diceRolled",
          player: playerIndex,
          result: result,
        });

        playDiceSound();
        // HOST ALSO SEES DICE ANIMATION
        showDiceAnimation(result);

        setTimeout(() => {
          const oldPosition = playerPositions[playerIndex];
          const newPosition = Math.min(oldPosition + result, boardPath.length);

          animatePlayerMovement(playerIndex, oldPosition, newPosition, () => {
            broadcastToPlayers({
              type: "positionUpdate",
              player: playerIndex,
              position: playerPositions[playerIndex],
            });

            if (playerPositions[playerIndex] >= boardPath.length) {
              handleWinnerOnline(playerIndex);
              return;
            }

            setTimeout(() => {
              checkSpaceAndAskQuestionOnline(playerIndex);
            }, 300);
          });
        }, 1000);
      }

      function checkSpaceAndAskQuestionOnline(playerIndex) {
        if (
          playerPositions[playerIndex] > 0 &&
          playerPositions[playerIndex] < boardPath.length
        ) {
          const spaceColor = boardPath[playerPositions[playerIndex]].color;

          if (
            spaceColor === "white" ||
            spaceColor === "green" ||
            spaceColor === "yellow" ||
            spaceColor === "red" ||
            spaceColor === "purple"
          ) {
            askQuestionOnline(spaceColor, playerIndex);
          } else {
            nextPlayerOnline();
          }
        } else {
          nextPlayerOnline();
        }
      }

      function askQuestionOnline(difficulty, playerIndex) {
        currentDifficulty = difficulty;

        drawCard(difficulty);

        const problemDifficulty = difficulty === "purple" ? "red" : difficulty;
        const problems = mathProblems[problemDifficulty];

        let problem;
        let attempts = 0;
        do {
          problem = problems[Math.floor(Math.random() * problems.length)];
          attempts++;
        } while (
          usedProblems[problemDifficulty].includes(problem.q) &&
          attempts < 50
        );

        if (attempts >= 50) {
          usedProblems[problemDifficulty] = [];
          problem = problems[Math.floor(Math.random() * problems.length)];
        }

        usedProblems[problemDifficulty].push(problem.q);
        currentQuestion = problem;

        // Show question on host screen with player answer field
        showQuestionOnHost(problem.q, gamePlayers[playerIndex].name);

        const player = gamePlayers[playerIndex];
        if (player.conn) {
          player.conn.send({
            type: "question",
            difficulty: difficulty,
            question: problem.q,
            timeLimit: getQuestionTimeLimit(difficulty),
          });
        }
      }

      function showQuestionOnHost(questionText, playerName) {
        const modal = document.getElementById("questionModal");
        const questionTextEl = document.getElementById("questionText");
        const answerInput = document.getElementById("answerInput");
        const checkBtn = document.getElementById("checkAnswerBtn");

        questionTextEl.innerHTML = `<small style="color: #ffd43b;">${playerName} odpowiada:</small><br>${questionText} = ?`;
        answerInput.value = "";
        answerInput.disabled = true;
        answerInput.placeholder = "Czekam na odpowied≈∫...";
        answerInput.style.background = "rgba(255,255,255,0.1)";
        checkBtn.style.display = "none";

        document.getElementById("correctAnswer").textContent = "";

        modal.style.display = "flex";

        // Hide timer for online mode
        document.getElementById("questionTimer").style.display = "none";
      }

      function updateQuestionModalAnswer(answer) {
        const answerInput = document.getElementById("answerInput");
        if (answerInput) {
          answerInput.value = answer;
          // NO COLOR FEEDBACK - just update the value
        }
      }

      function submitAnswerOnline(answer) {
        const playerIndex = currentPlayer;
        const userAnswer = parseInt(answer);
        const isCorrect = userAnswer === currentQuestion.a;

        // Show feedback on host screen for 3 seconds
        const correctAnswerEl = document.getElementById("correctAnswer");
        if (correctAnswerEl) {
          correctAnswerEl.style.display = "block";
          if (isCorrect) {
            correctAnswerEl.innerHTML =
              '<div style="color: #51cf66; font-size: 32px; font-weight: bold;">‚úì DOBRZE!</div>';
          } else {
            correctAnswerEl.innerHTML = `<div style="color: #ff6b6b; font-size: 32px; font-weight: bold;">‚úó ≈πLE!<br><span style="font-size: 20px;">Poprawna odpowied≈∫: ${currentQuestion.a}</span></div>`;
          }
        }

        // Send feedback to player
        const playerConn = gamePlayers[playerIndex].conn;
        if (playerConn && playerConn.open) {
          playerConn.send({
            type: "answerFeedback",
            correct: isCorrect,
          });
        }

        // Wait 3 seconds before processing result
        setTimeout(() => {
          if (correctAnswerEl) {
            correctAnswerEl.style.display = "none";
          }

          if (isCorrect) {
            handleCorrectAnswerOnline(playerIndex);
          } else {
            handleWrongAnswerOnline(playerIndex);
          }
        }, 3000);
      }

      function handleCorrectAnswerOnline(playerIndex) {
        // Close question modal on host
        document.getElementById("questionModal").style.display = "none";

        let movement = 0;
        let giveBonus = false;
        let teleport = false;
        let teleportTo = null;

        if (currentDifficulty === "white") {
          movement = 0;
        } else if (currentDifficulty === "purple") {
          const currentSpace = boardPath[playerPositions[playerIndex]];
          if (currentSpace.teleportTo !== undefined) {
            teleport = true;
            teleportTo = currentSpace.teleportTo;
          }
        } else if (currentDifficulty === "green") {
          movement = 1;
        } else if (currentDifficulty === "yellow") {
          movement = 2;
          if (!bonusRollInTurn) giveBonus = true;
        } else if (currentDifficulty === "red") {
          movement = 3;
          if (!bonusRollInTurn) giveBonus = true;
        }

        const oldPosition = playerPositions[playerIndex];
        let newPosition;

        if (teleport) {
          newPosition = Math.min(teleportTo, boardPath.length);
        } else {
          newPosition = Math.min(oldPosition + movement, boardPath.length);
        }

        animatePlayerMovement(playerIndex, oldPosition, newPosition, () => {
          broadcastToPlayers({
            type: "positionUpdate",
            player: playerIndex,
            position: playerPositions[playerIndex],
          });

          if (playerPositions[playerIndex] >= boardPath.length) {
            handleWinnerOnline(playerIndex);
            return;
          }

          if (giveBonus) {
            bonusRollInTurn = true;
            notifyPlayerTurn(playerIndex);
          } else {
            bonusRollInTurn = false;
            nextPlayerOnline();
          }
        });
      }

      function handleCheatOnline(conn, reason) {
        const playerIndex = currentPlayer;
        const player = gamePlayers[playerIndex];

        // Close question modal
        document.getElementById("questionModal").style.display = "none";

        // Show cheat notification
        showNotification(
          `üö® OSZUSTWO!\n${player.name}: ${reason}\nGracz zostaje cofniƒôty!`,
          "error"
        );

        // Send cheat notification to all players
        broadcastToPlayers({
          type: "cheatDetected",
          playerName: player.name,
          reason: reason,
        });

        // Penalty movement based on difficulty (same as wrong answer)
        let movement = 0;
        if (currentDifficulty === "white") {
          movement = -4;
        } else if (currentDifficulty === "purple") {
          movement = 0;
        } else if (currentDifficulty === "green") {
          movement = -3;
        } else if (currentDifficulty === "yellow") {
          movement = -2;
        } else if (currentDifficulty === "red") {
          movement = -1;
        }

        const oldPosition = playerPositions[playerIndex];
        const newPosition = Math.max(0, oldPosition + movement);

        animatePlayerMovement(playerIndex, oldPosition, newPosition, () => {
          broadcastToPlayers({
            type: "positionUpdate",
            player: playerIndex,
            position: playerPositions[playerIndex],
          });

          bonusRollInTurn = false;
          nextPlayerOnline();
        });
      }

      function handleWrongAnswerOnline(playerIndex) {
        // Close question modal on host
        document.getElementById("questionModal").style.display = "none";

        let movement = 0;

        if (currentDifficulty === "white") {
          movement = -4;
        } else if (currentDifficulty === "purple") {
          movement = 0;
        } else if (currentDifficulty === "green") {
          movement = -3;
        } else if (currentDifficulty === "yellow") {
          movement = -2;
        } else if (currentDifficulty === "red") {
          movement = -1;
        }

        const oldPosition = playerPositions[playerIndex];
        const newPosition = Math.max(0, oldPosition + movement);

        animatePlayerMovement(playerIndex, oldPosition, newPosition, () => {
          broadcastToPlayers({
            type: "positionUpdate",
            player: playerIndex,
            position: playerPositions[playerIndex],
          });

          bonusRollInTurn = false;
          nextPlayerOnline();
        });
      }

      function nextPlayerOnline() {
        bonusRollInTurn = false;
        currentPlayer = (currentPlayer + 1) % gamePlayers.length;
        notifyPlayerTurn(currentPlayer);
      }

      function handleWinnerOnline(playerIndex) {
        const player = gamePlayers[playerIndex];

        // Start fireworks
        startFireworks();

        // Show winner
        showNotification(`üéâüèÜ ${player.name} WYGRYWA! üèÜüéâ`, "success");

        // Send winner notification to all players
        broadcastToPlayers({
          type: "gameOver",
          winner: player.name,
          winnerColor: player.color,
        });

        // Start rematch voting after 3 seconds
        setTimeout(() => {
          startRematchVoting();
        }, 3000);
      }

      function broadcastToPlayers(message) {
        connections.forEach((conn) => {
          if (conn.open) {
            conn.send(message);
          }
        });
      }

      function startRematchVoting() {
        // Reset votes
        rematchVotes.clear();
        rematchTimeLeft = 15;

        // Show voting screen on host
        document.getElementById("rematchVotingScreen").style.display = "flex";
        updateRematchUI();

        // Request votes from all players
        broadcastToPlayers({
          type: "rematchVote",
          request: true,
        });

        // Start timer
        rematchTimer = setInterval(() => {
          rematchTimeLeft--;
          updateRematchUI();

          if (rematchTimeLeft <= 0) {
            // Timeout - check votes
            endRematchVoting();

            const totalPlayers = gamePlayers.length;
            const votedCount = rematchVotes.size;
            const allYes = Array.from(rematchVotes.values()).every(
              (v) => v === true
            );

            if (votedCount === totalPlayers && allYes) {
              resetToLobby();
            } else {
              showNotification(
                "Czas minƒÖ≈Ç lub nie wszyscy zag≈Çosowali TAK. Gra zako≈Ñczona.",
                "error"
              );
              setTimeout(() => {
                location.reload();
              }, 3000);
            }
          }
        }, 1000);
      }

      function voteRematch(vote) {
        if (!isHost) return;

        // Host's vote (fake connection for host)
        rematchVotes.set("host", vote);
        updateRematchUI();

        // Disable buttons after voting
        document.getElementById("rematchYesBtn").disabled = true;
        document.getElementById("rematchNoBtn").disabled = true;

        // Broadcast vote count to all players
        const yesVotes = Array.from(rematchVotes.values()).filter(
          (v) => v === true
        ).length;
        broadcastToPlayers({
          type: "rematchVote",
          voteCount: yesVotes,
          totalPlayers: gamePlayers.length,
        });

        checkRematchVotes();
      }

      function handleRematchVote(conn, vote) {
        rematchVotes.set(conn.peer, vote);
        updateRematchUI();

        // Broadcast vote count to all players
        const yesVotes = Array.from(rematchVotes.values()).filter(
          (v) => v === true
        ).length;
        broadcastToPlayers({
          type: "rematchVote",
          voteCount: yesVotes,
          totalPlayers: gamePlayers.length,
        });

        checkRematchVotes();
      }

      function updateRematchUI() {
        document.getElementById("rematchTimer").textContent = rematchTimeLeft;

        const yesVotes = Array.from(rematchVotes.values()).filter(
          (v) => v === true
        ).length;
        const totalPlayers = gamePlayers.length;
        document.getElementById(
          "rematchVoteCount"
        ).textContent = `${yesVotes}/${totalPlayers} graczy gotowych`;
      }

      function checkRematchVotes() {
        const totalPlayers = gamePlayers.length;
        const votedCount = rematchVotes.size;

        // Check if all players voted
        if (votedCount === totalPlayers) {
          // Check if all voted yes
          const allYes = Array.from(rematchVotes.values()).every(
            (v) => v === true
          );

          if (allYes) {
            endRematchVoting();
            resetToLobby();
          } else {
            endRematchVoting();
            showNotification(
              "Nie wszyscy gracze chcƒÖ graƒá ponownie. Gra zako≈Ñczona.",
              "error"
            );
            setTimeout(() => {
              location.reload();
            }, 3000);
          }
        }
      }

      function endRematchVoting() {
        if (rematchTimer) {
          clearInterval(rematchTimer);
          rematchTimer = null;
        }
        document.getElementById("rematchVotingScreen").style.display = "none";
      }

      function resetToLobby() {
        // Hide game screen
        document.getElementById("gameScreen").style.display = "none";

        // Show lobby
        document.getElementById("onlineLobby").style.display = "flex";

        // Reset game state but keep connections
        gamePlayers = [];
        currentPlayer = 0;
        playerPositions = [];
        playerPieces = [];
        usedProblems = { white: [], green: [], yellow: [], red: [] };
        bonusRollInTurn = false;

        // Clear board
        const canvas = document.getElementById("gameCanvas");
        const ctx = canvas.getContext("2d");
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawBoard();

        // Update lobby with current players
        updatePlayersWaitingList();

        // Enable start button if we have players
        const startBtn = document.getElementById("startOnlineBtn");
        if (onlinePlayers.length >= 2) {
          startBtn.disabled = false;
        }

        // Notify all players to return to waiting
        broadcastToPlayers({
          type: "returnToLobby",
        });

        showNotification(
          "Wszyscy zgodzili siƒô! Wracamy do poczekalni.",
          "success"
        );
      }

      // ===== MOBILE PLAYER MODE =====

      function initMobilePlayer(room) {
        if (mobileInitialized) return;
        mobileInitialized = true;
        roomId = room;

        // Load profile
        if (!loadPlayerProfile()) {
          alert("Musisz najpierw utworzyƒá profil! Otw√≥rz grƒô na komputerze.");
          return;
        }

        myPlayerName = playerProfile.name;
        myPlayerColor = playerProfile.color;

        // Show waiting
        showMobileScreen("mobileWaitingScreen");
        document.getElementById("mobileWaitingText").textContent =
          "‚è≥ ≈ÅƒÖczenie...";

        // Create peer and connect
        myPeer = new Peer();

        myPeer.on("open", function (id) {
          // Connect to host
          hostConnection = myPeer.connect(roomId);

          hostConnection.on("open", function () {
            // Send join
            hostConnection.send({
              type: "join",
              name: myPlayerName,
              color: myPlayerColor,
            });
          });

          hostConnection.on("data", handleHostMessage);

          hostConnection.on("error", function (err) {
            alert("B≈ÇƒÖd: " + err.type);
          });
        });

        myPeer.on("error", function (err) {
          alert("B≈ÇƒÖd po≈ÇƒÖczenia: " + err.type);
        });

        // Setup buttons
        setupMobileEventListeners();
      }

      function setupMobileEventListeners() {
        updateDebugInfo("Setting up event listeners");

        // Roll button
        const rollBtn = document.getElementById("mobileRollBtn");
        rollBtn.addEventListener("click", function (e) {
          mobileRollDice();
        });

        // Submit button
        const submitBtn = document.getElementById("mobileSubmitBtn");
        submitBtn.addEventListener("click", function (e) {
          mobileSubmitAnswer();
        });

        // Reload button
        const reloadBtn = document.getElementById("mobileReloadBtn");
        reloadBtn.addEventListener("click", function (e) {
          location.reload();
        });

        // Enter key for answer
        const answerInput = document.getElementById("mobileAnswerInput");
        answerInput.addEventListener("keypress", function (e) {
          if (e.key === "Enter") {
            mobileSubmitAnswer();
          }
        });

        updateDebugInfo("Event listeners ready");
      }

      function updateDebugInfo(message) {
        // Temporarily enabled for debugging connection issues
        // Will be disabled after testing
        return;

        const debugDiv = document.getElementById("mobileDebugInfo");
        if (debugDiv) {
          debugDiv.style.display = "block";
          const timestamp = new Date().toLocaleTimeString();
          debugDiv.textContent = `[${timestamp}] ${message}`;
        }
      }

      function getPolishColorName(color) {
        const names = {
          blue: "niebieski",
          red: "czerwony",
          green: "zielony",
          yellow: "≈º√≥≈Çty",
          purple: "fioletowy",
          orange: "pomara≈Ñczowy",
          pink: "r√≥≈ºowy",
          cyan: "cyjan",
        };
        return names[color] || color;
      }

      let handleHostMessageCount = 0;
      let lastHostMessage = null;
      let lastYourTurnTime = 0;
      let isCurrentlyMyTurn = false;

      function handleHostMessage(data) {
        if (data.type === "joined") {
          if (data.success) {
            // Update color if changed
            if (data.assignedColor) {
              myPlayerColor = data.assignedColor;
            }

            // Show connected message
            const waitingText = document.getElementById("mobileWaitingText");
            if (waitingText) {
              waitingText.innerHTML =
                "‚úÖ <strong>Po≈ÇƒÖczono!</strong><br>Czekam na start gry...";
            }

            showMobileScreen("mobileWaitingScreen");
          }
        } else if (data.type === "error") {
          alert(data.message);
        } else if (data.type === "gameStart") {
          allPlayers = data.players;
          currentTurn = data.currentPlayer;
          startMobileGame();
        } else if (data.type === "yourTurn") {
          isCurrentlyMyTurn = true;

          if (data.canRoll) {
            enableMobileRollButton();
          }
        } else if (data.type === "turnUpdate") {
          // Only update if turn actually changed
          if (currentTurn !== data.currentPlayer) {
            currentTurn = data.currentPlayer;
            isCurrentlyMyTurn = false; // No longer my turn
            updateMobileTurnMessage();
          }
        } else if (data.type === "diceRolled") {
          // Show dice result only for the player who rolled
          const myIndex = allPlayers.findIndex(
            (p) => p.name === myPlayerName && p.color === myPlayerColor
          );
          if (myIndex === data.player) {
            showMobileDiceResult(data.result);
          }
        } else if (data.type === "answerFeedback") {
          // Show feedback for 3 seconds
          showMobileAnswerFeedback(data.correct);
        } else if (data.type === "question") {
          // Only show question if we're on game screen (not already on question screen)
          if (currentMobileScreen === "mobileGameScreen") {
            showMobileQuestion(data);
          }
        } else if (data.type === "cheatDetected") {
          // Show cheat notification on mobile
          showMobileScreen("mobileGameScreen");
          const turnMessage = document.getElementById("mobileTurnMessage");
          if (turnMessage) {
            turnMessage.innerHTML =
              '<div style="font-size: 40px; color: #ff6b6b; animation: bounce 0.5s ease;">üö® OSZUSTWO!<br><span style="font-size: 24px;">Zosta≈Çe≈õ cofniƒôty!</span></div>';
            setTimeout(() => {
              updateMobileTurnMessage();
            }, 3000);
          }
          isAnsweringQuestion = false;
        } else if (data.type === "gameOver") {
          showMobileWinner(data.winner, data.winnerColor);
        } else if (data.type === "rematchVote") {
          if (data.request) {
            // Show voting UI
            showMobileRematchVoting();
          } else if (data.voteCount !== undefined) {
            // Update vote count
            updateMobileRematchVoteCount(data.voteCount, data.totalPlayers);
          }
        } else if (data.type === "returnToLobby") {
          // Return to waiting screen
          showMobileScreen("mobileWaitingScreen");
          document.getElementById("mobileWaitingText").innerHTML =
            "‚úÖ <strong>Po≈ÇƒÖczono!</strong><br>Czekam na start gry...";
        }
      }

      let currentMobileScreen = "";
      let lastScreenChangeTime = 0;

      function showMobileScreen(screenId) {
        // Hide all screens
        const screens = document.querySelectorAll(".mobile-player-screen");
        screens.forEach((screen) => {
          screen.classList.remove("active");
        });

        // Show requested screen
        const targetScreen = document.getElementById(screenId);
        if (targetScreen) {
          targetScreen.classList.add("active");
        }

        currentMobileScreen = screenId;
      }

      function showMobileError(message) {
        const waitingText = document.getElementById("mobileWaitingText");
        if (waitingText) {
          waitingText.innerHTML = `<span style="color: #ff6b6b;">‚ùå ${message}</span>`;
        }

        // Also show alert as backup
        setTimeout(() => {
          alert(message);
        }, 100);
      }

      function startMobileGame() {
        showMobileScreen("mobileGameScreen");
        updateMobileTurnMessage();
      }

      function updateMobileTurnMessage() {
        const messageDiv = document.getElementById("mobileTurnMessage");
        if (!messageDiv) return;

        const myIndex = allPlayers.findIndex(
          (p) => p.name === myPlayerName && p.color === myPlayerColor
        );

        let newHTML;
        if (myIndex === currentTurn) {
          newHTML =
            '<strong style="color: #51cf66; font-size: 22px;">üé≤ TWOJA KOLEJ!</strong>';
        } else {
          newHTML = `Tura gracza: <strong>${allPlayers[currentTurn].name}</strong><br><span class="loading">Czekaj...</span>`;
        }

        // Only update if changed
        if (newHTML !== lastTurnMessageHTML) {
          messageDiv.innerHTML = newHTML;
          lastTurnMessageHTML = newHTML;
        }
      }

      function enableMobileRollButton() {
        const rollBtn = document.getElementById("mobileRollBtn");
        rollBtn.disabled = false;
        updateMobileTurnMessage();
      }

      function mobileRollDice() {
        const rollBtn = document.getElementById("mobileRollBtn");
        rollBtn.disabled = true;

        hostConnection.send({
          type: "roll",
        });
      }

      function showMobileDiceResult(result) {
        // Show dice animation with random numbers
        const turnMessage = document.getElementById("mobileTurnMessage");
        if (turnMessage) {
          let count = 0;
          const interval = setInterval(() => {
            const randomNum = Math.floor(Math.random() * 6) + 1;
            turnMessage.innerHTML = `<div style="font-size: 80px; margin: 20px 0;">üé≤ ${randomNum}</div>`;
            count++;
            if (count > 10) {
              clearInterval(interval);
              // Show final result with bounce animation
              turnMessage.innerHTML = `<div style="font-size: 80px; margin: 20px 0; animation: bounce 0.5s ease;">üé≤ ${result}</div>`;
            }
          }, 80);

          // Hide after animation completes
          setTimeout(() => {
            updateMobileTurnMessage();
          }, 1500);
        }
      }

      function showMobileQuestion(data) {
        showMobileScreen("mobileQuestionScreen");
        isAnsweringQuestion = true;

        document.getElementById("mobileQuestionText").textContent =
          data.question + " = ?";
        const answerInput = document.getElementById("mobileAnswerInput");
        answerInput.value = "";

        // Send answer updates in real-time (without color feedback)
        answerInput.oninput = function () {
          if (hostConnection && hostConnection.open) {
            hostConnection.send({
              type: "answerUpdate",
              answer: this.value,
            });
          }
        };

        // Focus after a small delay to ensure screen is shown
        setTimeout(() => {
          answerInput.focus();
        }, 300);

        startMobileQuestionTimer(data.timeLimit);
      }

      // Anti-cheat system - detect when player switches apps
      document.addEventListener("visibilitychange", function () {
        if (document.hidden && isAnsweringQuestion) {
          // Player switched to another app (e.g. calculator) while answering
          if (hostConnection && hostConnection.open) {
            hostConnection.send({
              type: "cheat",
              reason: "Zmiana aplikacji podczas odpowiadania",
            });
          }
          isAnsweringQuestion = false;
        }
      });

      function startMobileQuestionTimer(seconds) {
        if (mobileQuestionTimer) {
          clearInterval(mobileQuestionTimer);
        }

        let timeLeft = seconds;
        updateMobileTimerDisplay(timeLeft, seconds);

        mobileQuestionTimer = setInterval(() => {
          timeLeft--;
          updateMobileTimerDisplay(timeLeft, seconds);

          if (timeLeft <= 0) {
            clearInterval(mobileQuestionTimer);
            mobileSubmitAnswer();
          }
        }, 1000);
      }

      function updateMobileTimerDisplay(timeLeft, total) {
        const timerEl = document.getElementById("mobileTimer");
        const minutes = Math.floor(timeLeft / 60);
        const seconds = timeLeft % 60;
        timerEl.textContent = `${minutes}:${seconds
          .toString()
          .padStart(2, "0")}`;

        timerEl.classList.remove("warning", "danger");
        if (timeLeft <= 10) {
          timerEl.classList.add("danger");
        } else if (timeLeft <= total / 3) {
          timerEl.classList.add("warning");
        }
      }

      function mobileSubmitAnswer() {
        if (mobileQuestionTimer) {
          clearInterval(mobileQuestionTimer);
        }

        const answerInput = document.getElementById("mobileAnswerInput");
        const answer = answerInput.value;

        hostConnection.send({
          type: "answer",
          answer: answer,
        });

        isAnsweringQuestion = false; // Stop anti-cheat detection
        showMobileScreen("mobileGameScreen");
        document.getElementById("mobileRollBtn").disabled = true;
      }

      function showMobileAnswerFeedback(correct) {
        const turnMessage = document.getElementById("mobileTurnMessage");
        if (!turnMessage) return;

        if (correct) {
          turnMessage.innerHTML =
            '<div style="font-size: 60px; color: #51cf66; animation: bounce 0.5s ease;">‚úì DOBRZE!</div>';
        } else {
          turnMessage.innerHTML =
            '<div style="font-size: 60px; color: #ff6b6b; animation: bounce 0.5s ease;">‚úó ≈πLE!</div>';
        }

        // Return to normal after 3 seconds
        setTimeout(() => {
          updateMobileTurnMessage();
        }, 3000);
      }

      function showMobileWinner(winnerName, winnerColor) {
        showMobileScreen("mobileWinnerScreen");
        const message = document.getElementById("mobileWinnerMessage");
        const colorHex = getPlayerColor(winnerColor);
        message.innerHTML =
          `<div style="font-size: 32px; margin: 20px 0;">üèÜ</div>` +
          `<strong style="color: ${colorHex}; font-size: 28px; text-shadow: 0 0 10px ${colorHex};">${winnerName}</strong>` +
          `<div style="font-size: 20px; margin-top: 10px;">WYGRYWA!</div>`;

        // Hide rematch voting initially
        document.getElementById("mobileRematchVoting").style.display = "none";
      }

      let mobileRematchTimer = null;
      let mobileRematchTimeLeft = 15;

      function showMobileRematchVoting() {
        document.getElementById("mobileRematchVoting").style.display = "block";
        mobileRematchTimeLeft = 15;

        // Setup button handlers
        const yesBtn = document.getElementById("mobileRematchYesBtn");
        const noBtn = document.getElementById("mobileRematchNoBtn");

        yesBtn.onclick = () => voteMobileRematch(true);
        noBtn.onclick = () => voteMobileRematch(false);

        // Start timer
        mobileRematchTimer = setInterval(() => {
          mobileRematchTimeLeft--;
          document.getElementById("mobileRematchTimer").textContent =
            mobileRematchTimeLeft;

          if (mobileRematchTimeLeft <= 0) {
            clearInterval(mobileRematchTimer);
            // Auto vote no if timeout
            voteMobileRematch(false);
          }
        }, 1000);
      }

      function voteMobileRematch(vote) {
        // Stop timer
        if (mobileRematchTimer) {
          clearInterval(mobileRematchTimer);
          mobileRematchTimer = null;
        }

        // Send vote to host
        hostConnection.send({
          type: "rematchVote",
          vote: vote,
        });

        // Disable buttons
        document.getElementById("mobileRematchYesBtn").disabled = true;
        document.getElementById("mobileRematchNoBtn").disabled = true;

        // Show waiting message
        document.getElementById("mobileRematchVoteCount").textContent =
          "Czekam na innych...";
      }

      function updateMobileRematchVoteCount(voteCount, totalPlayers) {
        document.getElementById(
          "mobileRematchVoteCount"
        ).textContent = `${voteCount}/${totalPlayers} graczy gotowych`;
      }

      // ===== FIREWORKS =====
      let fireworksCanvas = null;
      let fireworksCtx = null;
      let fireworks = [];
      let particles = [];
      let fireworksInterval = null;

      function createFireworksCanvas() {
        if (fireworksCanvas) return;

        fireworksCanvas = document.createElement("canvas");
        fireworksCanvas.style.position = "fixed";
        fireworksCanvas.style.top = "0";
        fireworksCanvas.style.left = "0";
        fireworksCanvas.style.width = "100%";
        fireworksCanvas.style.height = "100%";
        fireworksCanvas.style.pointerEvents = "none";
        fireworksCanvas.style.zIndex = "9999";
        fireworksCanvas.width = window.innerWidth;
        fireworksCanvas.height = window.innerHeight;
        document.body.appendChild(fireworksCanvas);

        fireworksCtx = fireworksCanvas.getContext("2d");
      }

      function startFireworks() {
        createFireworksCanvas();
        fireworks = [];
        particles = [];

        // Launch fireworks every 400ms
        fireworksInterval = setInterval(() => {
          launchFirework();
        }, 400);

        // Stop after 5 seconds
        setTimeout(() => {
          stopFireworks();
        }, 5000);

        animateFireworks();
      }

      function stopFireworks() {
        if (fireworksInterval) {
          clearInterval(fireworksInterval);
          fireworksInterval = null;
        }

        // Let particles fade out, then remove canvas
        setTimeout(() => {
          if (fireworksCanvas) {
            document.body.removeChild(fireworksCanvas);
            fireworksCanvas = null;
            fireworksCtx = null;
          }
        }, 2000);
      }

      function launchFirework() {
        const colors = [
          "#ff6b6b",
          "#51cf66",
          "#667eea",
          "#ffd43b",
          "#ff66cc",
          "#66d9ff",
        ];
        const x = Math.random() * fireworksCanvas.width;
        const y = fireworksCanvas.height;
        const targetY = Math.random() * (fireworksCanvas.height * 0.3) + 50;
        const color = colors[Math.floor(Math.random() * colors.length)];

        fireworks.push({
          x: x,
          y: y,
          targetY: targetY,
          velocity: 8,
          color: color,
          exploded: false,
        });

        // Play explosion sound
        playFireworkSound();
      }

      function animateFireworks() {
        if (!fireworksCtx) return;

        fireworksCtx.fillStyle = "rgba(0, 0, 0, 0.1)";
        fireworksCtx.fillRect(
          0,
          0,
          fireworksCanvas.width,
          fireworksCanvas.height
        );

        // Update fireworks
        for (let i = fireworks.length - 1; i >= 0; i--) {
          const fw = fireworks[i];

          if (!fw.exploded) {
            fw.y -= fw.velocity;

            // Draw rocket
            fireworksCtx.beginPath();
            fireworksCtx.arc(fw.x, fw.y, 3, 0, Math.PI * 2);
            fireworksCtx.fillStyle = fw.color;
            fireworksCtx.fill();

            // Explode when reaching target
            if (fw.y <= fw.targetY) {
              fw.exploded = true;
              createParticles(fw.x, fw.y, fw.color);
              fireworks.splice(i, 1);
            }
          }
        }

        // Update particles
        for (let i = particles.length - 1; i >= 0; i--) {
          const p = particles[i];

          p.x += p.vx;
          p.y += p.vy;
          p.vy += 0.1; // gravity
          p.alpha -= 0.01;

          if (p.alpha > 0) {
            fireworksCtx.beginPath();
            fireworksCtx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
            fireworksCtx.fillStyle = `rgba(${p.color}, ${p.alpha})`;
            fireworksCtx.fill();
          } else {
            particles.splice(i, 1);
          }
        }

        if (fireworksInterval || particles.length > 0) {
          requestAnimationFrame(animateFireworks);
        }
      }

      function createParticles(x, y, color) {
        const particleCount = 50;

        // Convert hex color to RGB
        const r = parseInt(color.slice(1, 3), 16);
        const g = parseInt(color.slice(3, 5), 16);
        const b = parseInt(color.slice(5, 7), 16);
        const rgbColor = `${r}, ${g}, ${b}`;

        for (let i = 0; i < particleCount; i++) {
          const angle = (Math.PI * 2 * i) / particleCount;
          const speed = Math.random() * 4 + 2;

          particles.push({
            x: x,
            y: y,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed,
            alpha: 1,
            color: rgbColor,
            size: Math.random() * 3 + 1,
          });
        }
      }

      function playFireworkSound() {
        // Create explosion sound using Web Audio API
        const audioContext = new (window.AudioContext ||
          window.webkitAudioContext)();

        // White noise for explosion
        const bufferSize = audioContext.sampleRate * 0.3;
        const buffer = audioContext.createBuffer(
          1,
          bufferSize,
          audioContext.sampleRate
        );
        const data = buffer.getChannelData(0);

        for (let i = 0; i < bufferSize; i++) {
          data[i] = Math.random() * 2 - 1;
        }

        const noise = audioContext.createBufferSource();
        noise.buffer = buffer;

        const filter = audioContext.createBiquadFilter();
        filter.type = "lowpass";
        filter.frequency.value = 1000;

        const gain = audioContext.createGain();
        gain.gain.setValueAtTime(0.3, audioContext.currentTime);
        gain.gain.exponentialRampToValueAtTime(
          0.01,
          audioContext.currentTime + 0.3
        );

        noise.connect(filter);
        filter.connect(gain);
        gain.connect(audioContext.destination);

        noise.start();
        noise.stop(audioContext.currentTime + 0.3);
      }
    </script>
  </body>
</html>
